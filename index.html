<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulation - Three.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* HUD Container */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* App Title - Centered at Top */
        #app-title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Time Control Panel */
        #time-control {
            position: fixed;
            top: 20px;
            /* Moved higher (was 70px) */
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 15px;
            border-radius: 10px;
            color: white;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 650px;
            pointer-events: all;
            /* CRITICAL: Make controls clickable */
        }

        #time-control h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #64b5f6;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            flex-wrap: nowrap;
            /* Keep items on same row */
        }

        #time-slider {
            flex: 1;
            min-width: 150px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        #time-value {
            font-size: 13px;
            color: #fff;
            min-width: 50px;
            text-align: right;
        }

        .btn {
            background: rgba(136, 136, 255, 0.2);
            border: 1px solid rgba(136, 136, 255, 0.4);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(136, 136, 255, 0.4);
        }

        .btn-awake {
            background: rgba(220, 38, 38, 0.3);
            border: 1px solid rgba(220, 38, 38, 0.6);
            color: #fff;
            font-weight: bold;
        }

        .btn-awake:hover {
            background: rgba(220, 38, 38, 0.5);
        }

        .btn-awake.active {
            background: rgba(220, 38, 38, 0.7);
            border-color: rgba(220, 38, 38, 0.9);
        }

        /* Planet Label Tooltip */
        #planet-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
            z-index: 200;
        }

        #planet-label.visible {
            opacity: 1;
        }

        #planet-label h2 {
            margin: 0 0 8px 0;
            font-size: 18px;
            color: #88f;
        }

        #planet-label p {
            margin: 4px 0;
            font-size: 13px;
            color: #ccc;
        }

        /* Performance Monitor */
        #performance {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }

        /* Help Button */
        #help-btn {
            position: fixed;
            top: 20px;
            left: 670px;
            /* Positioned to the right of time-control panel */
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 20px;
            font-weight: bold;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: all;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #help-btn:hover {
            background: rgba(0, 0, 0, 0.95);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        /* Instructions Overlay */
        #instructions {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 2000;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #instructions.visible {
            display: flex;
            opacity: 1;
        }

        #instructions-content {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            font-size: 14px;
            position: relative;
        }

        #instructions h3 {
            margin: 0 0 20px 0;
            color: #88f;
            font-size: 24px;
            text-align: center;
        }

        #instructions ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #instructions li {
            margin: 10px 0;
            color: #ccc;
            line-height: 1.6;
        }

        #instructions kbd {
            background: rgba(255, 255, 255, 0.15);
            padding: 4px 8px;
            border-radius: 4px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #close-help {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        #close-help:hover {
            opacity: 1;
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #88f;
        }

        #loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        #loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #88f, #f8f);
            width: 0%;
            transition: width 0.3s;
        }

        #loading-text {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h1>üåå Solar System Loading...</h1>
        <div id="loading-progress">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-text">Loading textures...</div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- HUD Overlay -->
    <div id="hud">
        <!-- Centered App Title -->
        <div id="app-title">ÈÉëÊ∫êÊù• Solar System</div>

        <!-- Compact Control Panel -->
        <div id="time-control">
            <!-- Row 1: Slider + Buttons all in one row -->
            <div class="control-row">
                <input type="range" id="time-slider" min="0" max="100" value="3" step="1">
                <span id="time-value" style="min-width: 45px; font-size: 13px;">0.3x</span>
                <button id="pause-btn" class="btn" style="padding: 5px 10px; font-size: 11px;">‚è∏Ô∏è Pause</button>
                <button id="reset-btn" class="btn" style="padding: 5px 10px; font-size: 11px;">üîÑ Reset</button>
                <button id="awake-btn" class="btn btn-awake" style="padding: 5px 10px; font-size: 11px;">üî¥
                    Awake</button>
                <button id="solarballs-btn" class="btn"
                    style="padding: 5px 10px; font-size: 11px; background: rgba(255, 200, 0, 0.2); border-color: rgba(255, 200, 0, 0.4);">üòä
                    Solar Balls</button>
            </div>

            <!-- Row 2: Navigation dropdown full width -->
            <div class="control-row" style="margin-bottom: 0;">
                <select id="nav-select">
                    <option value="">Select Planet or Moon...</option>
                    <optgroup label="‚òÄÔ∏è Sun">
                        <option value="sun">Sun</option>
                    </optgroup>
                    <optgroup label="‚òøÔ∏è Mercury">
                        <option value="mercury">Mercury</option>
                    </optgroup>
                    <optgroup label="‚ôÄÔ∏è Venus">
                        <option value="venus">Venus</option>
                    </optgroup>
                    <optgroup label="üåç Earth">
                        <option value="earth">Earth</option>
                        <option value="moon"> ‚Ä¢ Moon</option>
                    </optgroup>
                    <optgroup label="‚ôÇÔ∏è Mars">
                        <option value="mars">Mars</option>
                        <option value="phobos"> ‚Ä¢ Phobos</option>
                        <option value="deimos"> ‚Ä¢ Deimos</option>
                    </optgroup>
                    <optgroup label="‚ôÉ Jupiter">
                        <option value="jupiter">Jupiter</option>
                        <option value="io"> ‚Ä¢ Io</option>
                        <option value="europa"> ‚Ä¢ Europa</option>
                        <option value="ganymede"> ‚Ä¢ Ganymede</option>
                        <option value="callisto"> ‚Ä¢ Callisto</option>
                    </optgroup>
                    <optgroup label="‚ôÑ Saturn">
                        <option value="saturn">Saturn</option>
                        <option value="titan"> ‚Ä¢ Titan</option>
                        <option value="enceladus"> ‚Ä¢ Enceladus</option>
                        <option value="rhea"> ‚Ä¢ Rhea</option>
                        <option value="iapetus"> ‚Ä¢ Iapetus</option>
                    </optgroup>
                    <optgroup label="‚ôÖ Uranus">
                        <option value="uranus">Uranus</option>
                        <option value="miranda"> ‚Ä¢ Miranda</option>
                        <option value="ariel"> ‚Ä¢ Ariel</option>
                        <option value="umbriel"> ‚Ä¢ Umbriel</option>
                        <option value="titania"> ‚Ä¢ Titania</option>
                        <option value="oberon"> ‚Ä¢ Oberon</option>
                    </optgroup>
                    <optgroup label="‚ôÜ Neptune">
                        <option value="neptune">Neptune</option>
                        <option value="triton"> ‚Ä¢ Triton</option>
                    </optgroup>
                    <optgroup label="‚ôá Pluto">
                        <option value="pluto">Pluto</option>
                    </optgroup>
                    <optgroup label="ü™® Asteroid Belt">
                        <option value="ceres">Ceres</option>
                    </optgroup>
                    <optgroup label="‚òÑÔ∏è Kuiper Belt Objects">
                        <option value="orcus">Orcus</option>
                        <option value="haumea">Haumea</option>
                        <option value="quaoar">Quaoar</option>
                        <option value="makemake">Makemake</option>
                    </optgroup>
                    <optgroup label="üí´ Scattered Disk">
                        <option value="eris">Eris</option>
                        <option value="gonggong">Gonggong</option>
                    </optgroup>
                    <optgroup label="üåå Inner Oort Cloud">
                        <option value="sedna">Sedna</option>
                    </optgroup>
                    <optgroup label="üå† Outer System">
                        <option value="ots 44">OTS 44</option>
                        <option value="wise 0855-0714">WISE 0855-0714</option>
                        <option value="ogle-2016-blg-1928">OGLE-2016-BLG-1928</option>
                        <option value="pso j318.5-22">PSO J318.5-22</option>
                        <option value="simp0136">SIMP0136</option>
                        <option value="planet x">Planet X</option>
                    </optgroup>
                    <optgroup label="‚òÑÔ∏è Kuiper Belt">
                        <option value="kuiper">Kuiper Belt</option>
                    </optgroup>
                    <optgroup label="üåê Planet QQ">
                        <option value="planetqq">Planet QQ</option>
                    </optgroup>
                    <optgroup label="üï≥Ô∏è Black Hole">
                        <option value="blackhole">Black Hole</option>
                    </optgroup>
                </select>
            </div>
        </div>

        <!-- Planet Label -->
        <div id="planet-label"></div>

        <!-- Performance Monitor -->
        <div id="performance">
            FPS: <span id="fps">60</span> |
            Objects: <span id="objects">0</span>
        </div>

        <!-- Help Button -->
        <button id="help-btn" title="Show Controls">H</button>

        <!-- Instructions Overlay (Hidden by default) -->
        <div id="instructions">
            <div id="instructions-content">
                <button id="close-help" title="Close">√ó</button>
                <h3>üéÆ Controls</h3>
                <ul>
                    <li><kbd>W/A/S/D</kbd> Fly Camera (Forward/Left/Back/Right)</li>
                    <li><kbd>Space</kbd> Fly Up | <kbd>Shift</kbd> Fly Down/Boost</li>
                    <li><kbd>Left-Click Drag</kbd> Rotate View</li>
                    <li><kbd>Right-Click Drag</kbd> Pan Camera</li>
                    <li><kbd>Scroll Wheel</kbd> Zoom In/Out</li>
                    <li><kbd>Click Planet</kbd> Fly To Planet</li>
                    <li><kbd>1-9</kbd> Jump to Planets | <kbd>0</kbd> Planet QQ | <kbd>-</kbd> Black Hole</li>
                    <li>Planet labels appear when close!</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            educational: {
                sunRadius: 100,        // Much larger for realistic scale
                planetSizeScale: 1.5,  // Exaggerate planet sizes
                moonSizeScale: 0.8,
                distanceScale: 1.0,     // Logarithmic spacing applied separately
                timeScale: 0.3,         // Default time speed (slower for observation)
                asteroidCount: 1000
            },
            camera: {
                fov: 75,
                near: 0.1,
                far: 50000,  // Increased from 10000 to support outer system bodies (up to 400 AU)
                moveSpeed: 2.0,
                boostMultiplier: 3.0,
                mouseSensitivity: 0.002
            },
            rendering: {
                bloom: {
                    strength: 1.5,
                    radius: 0.4,
                    threshold: 0.85
                }
            }
        };

        // Planetary data with more accurate relative sizes and spacing
        const PLANETS = [
            { name: 'Mercury', radius: 1.8, distance: 144, orbit: 88, rotation: 58, color: 0x8c8c8c, moons: [] },
            { name: 'Venus', radius: 4.2, distance: 180, orbit: 225, rotation: 243, color: 0xffc649, moons: [] },
            { name: 'Earth', radius: 4.5, distance: 240, orbit: 365, rotation: 1, color: 0x4169e1, moons: ['Moon'] },
            { name: 'Mars', radius: 2.5, distance: 315, orbit: 687, rotation: 1.03, color: 0xcd5c5c, moons: ['Phobos', 'Deimos'] },
            { name: 'Jupiter', radius: 40, distance: 600, orbit: 4333, rotation: 0.41, color: 0xdaa520, moons: ['Io', 'Europa', 'Ganymede', 'Callisto'] },
            { name: 'Saturn', radius: 32, distance: 900, orbit: 10759, rotation: 0.45, color: 0xf4a460, moons: ['Titan', 'Enceladus', 'Rhea', 'Iapetus'], hasRings: true },
            { name: 'Uranus', radius: 18, distance: 1200, orbit: 30687, rotation: 0.72, color: 0x4fd0e0, moons: ['Miranda', 'Ariel', 'Umbriel', 'Titania', 'Oberon'], hasRings: true, ringTilt: 'vertical' },
            { name: 'Neptune', radius: 17, distance: 1500, orbit: 60190, rotation: 0.67, color: 0x4169e1, moons: ['Triton'] },
            { name: 'Pluto', radius: 3.6, distance: 1860, orbit: 90560, rotation: 6.39, color: 0xc4a582, moons: [] },
            { name: 'Planet QQ', radius: 18, distance: 2760, orbit: 120000, rotation: 0.8, color: 0x8888ff, moons: [] }
        ];

        // Moon orbital data (relative to parent planet) - Larger sizes for visibility
        const MOON_DATA = {
            'Moon': { radius: 3.0, distance: 24, orbit: 27.3 },
            'Phobos': { radius: 1.2, distance: 10, orbit: 0.32 },
            'Deimos': { radius: 1.0, distance: 14, orbit: 1.26 },
            'Io': { radius: 3.2, distance: 56, orbit: 1.77 },
            'Europa': { radius: 3.0, distance: 70, orbit: 3.55 },
            'Ganymede': { radius: 4.5, distance: 90, orbit: 7.15 },
            'Callisto': { radius: 4.0, distance: 110, orbit: 16.69 },
            'Titan': { radius: 4.2, distance: 80, orbit: 15.95 },
            'Enceladus': { radius: 1.8, distance: 50, orbit: 1.37 },
            'Rhea': { radius: 2.2, distance: 64, orbit: 4.52 },
            'Iapetus': { radius: 2.0, distance: 96, orbit: 79.33 },
            'Miranda': { radius: 1.5, distance: 36, orbit: 1.41 },
            'Ariel': { radius: 1.8, distance: 44, orbit: 2.52 },
            'Umbriel': { radius: 1.8, distance: 56, orbit: 4.14 },
            'Titania': { radius: 2.2, distance: 70, orbit: 8.71 },
            'Oberon': { radius: 2.2, distance: 84, orbit: 13.46 },
            'Triton': { radius: 2.8, distance: 60, orbit: 5.88 }
        };

        // Minor Planets (Asteroid Belt)
        const MINOR_PLANETS = [
            { name: 'Ceres', radius: 3.0, distance: 277, orbit: 1680, rotation: 0.38, color: 0x6b8ba3, type: 'asteroid' }
        ];

        // Trans-Neptunian Objects (Kuiper Belt, Scattered Disk, Inner Oort Cloud)
        const TRANS_NEPTUNIAN_OBJECTS = [
            // Kuiper Belt (30-50 AU)
            { name: 'Orcus', radius: 3.0, distance: 1568, orbit: 92880, rotation: 10.5, color: 0x8b7d6b, type: 'kuiper' },
            { name: 'Haumea', radius: 3.0, distance: 1720, orbit: 103950, rotation: 0.16, color: 0xc0c0c0, type: 'kuiper', shape: 'ellipsoid', rings: 1 },
            { name: 'Quaoar', radius: 3.0, distance: 1748, orbit: 104730, rotation: 17.7, color: 0xa0522d, type: 'kuiper', rings: 2 },
            { name: 'Makemake', radius: 3.0, distance: 1832, orbit: 111780, rotation: 22.5, color: 0xcd853f, type: 'kuiper' },
            // Scattered Disk (50-100 AU)
            { name: 'Eris', radius: 3.0, distance: 2708, orbit: 203670, rotation: 25.9, color: 0xd3d3d3, type: 'scattered' },
            { name: 'Gonggong', radius: 3.0, distance: 2700, orbit: 201960, rotation: 22.4, color: 0x8b0000, type: 'scattered' },
            // Inner Oort Cloud
            { name: 'Sedna', radius: 3.0, distance: 3040, orbit: 241920, rotation: 10.3, color: 0xcd5c5c, type: 'oort' }
        ];

        // Fictional Outer System Bodies (just beyond Planet QQ at 2760)
        const OUTER_SYSTEM_BODIES = [
            { name: 'OTS 44', radius: 3.0, distance: 3000, orbit: 164000, rotation: 12, color: 0xff8c00, type: 'outer' },
            { name: 'WISE 0855-0714', radius: 3.0, distance: 3300, orbit: 189000, rotation: 8, color: 0x4682b4, type: 'outer' },
            { name: 'OGLE-2016-BLG-1928', radius: 3.0, distance: 3600, orbit: 216000, rotation: 15, color: 0x191970, type: 'outer' },
            { name: 'PSO J318.5-22', radius: 3.0, distance: 3900, orbit: 243000, rotation: 5, color: 0x9370db, type: 'outer' },
            { name: 'SIMP0136', radius: 40, distance: 4200, orbit: 272000, rotation: 2.4, color: 0x8b0000, type: 'outer' },
            { name: 'Planet X', radius: 3.0, distance: 4500, orbit: 302000, rotation: 20, color: 0x1e90ff, type: 'outer' }
        ];


        // ==================== SCENE SETUP ====================
        let scene, camera, renderer, composer, controls;
        let sun, planets = [], moons = [], asteroidBelt, kuiperBelt;
        let minorPlanets = [], transNeptunianObjects = [], outerSystemBodies = []; // New celestial body arrays
        let celestialObjects = []; // For raycasting
        let comets = []; // Comets with tails
        let shootingStars = []; // Fast meteors
        let timeScale = CONFIG.educational.timeScale;
        let isPaused = false;
        let elapsedTime = 0;
        let planetLabels = []; // Track planet labels for proximity display
        let asteroidMode = false; // Targeting mode for asteroid launcher
        let activeAsteroids = []; // Active asteroid projectiles
        let explosions = []; // Explosion effects
        let isAwakeMode = false; // Track awake/normal texture mode
        let isSolarBallsMode = false; // Track Solar Balls mode

        // Map of celestial bodies that have awake versions
        const AWAKE_TEXTURES = {
            'Mercury': { normal: 'textures/planets/mercury.jpg', awake: 'textures/planets/awake_mercury.png' },
            'Earth': { normal: 'textures/planets/earth_daymap.jpg', awake: 'textures/planets/awake_earth_daymap.png' },
            'Venus': { normal: 'textures/planets/venus_surface.jpg', awake: 'textures/planets/awake_venus.png' },
            'Mars': { normal: 'textures/planets/mars.jpg', awake: 'textures/planets/awake_mars.png' },
            'Jupiter': { normal: 'textures/planets/jupiter.jpg', awake: 'textures/planets/awake_jupiter.png' },
            'Saturn': { normal: 'textures/planets/saturn.jpg', awake: 'textures/planets/awake_staturn.png' },
            'Uranus': { normal: 'textures/planets/uranus.jpg', awake: 'textures/planets/awake_uranus.png' },
            'Neptune': { normal: 'textures/planets/neptune.jpg', awake: 'textures/planets/awake_neptune.png' },
            'Moon': { normal: 'textures/moons/moon.jpg', awake: 'textures/planets/awake_moon.png' }
        };

        // Map of celestial bodies with Solar Balls versions
        const SOLARBALLS_TEXTURES = {
            'Mercury': 'textures/planets/solarballs_mercury.jpg',
            'Venus': 'textures/planets/solarballs_venus.jpg',
            'Earth': 'textures/planets/solarballs_earth.jpg',
            'Mars': 'textures/planets/solarballs_mars.jpg',
            'Jupiter': 'textures/planets/solarballs_jupiter.jpg',
            'Saturn': 'textures/planets/solarballs_saturn.jpg',
            'Uranus': 'textures/planets/solarballs_uranus.jpg',
            'Neptune': 'textures/planets/solarballs_neptune.jpg',
            'Pluto': 'textures/planets/solarballs_pluto.jpg'
        };

        // WASD flight controls
        let keyStates = {
            w: false,
            a: false,
            s: false,
            d: false,
            shift: false,
            space: false
        };
        const moveSpeed = 5.0; // Base movement speed
        const boostMultiplier = 3.0; // Speed boost when holding Shift

        // Black hole configuration and state
        const BH_CONFIG = {
            G: 1.0,
            M: 1.0,
            c: 1.0,
            diskInner: 2.5,  // Smaller gap between event horizon and disk
            diskOuter: 5.95,  // 50% narrower (was 11.9)
            particleCount: 15000,  // Much denser disk
            particleSize: 0.25,  // Larger particles
            position: new THREE.Vector3(11040, 0, 0),  // 4√ó Planet QQ distance
            scale: 800,  // 10x larger for visibility
            beamingPower: 1.9,
            diskTiltDeg: 20  // Tilted 20 degrees
        };
        let blackHoleParticles, blackHoleSphere, photonRing, photonGlow;
        let bhParticleState, bhParticleVel;

        // Meteorite system for black hole accretion
        const meteorites = [];
        let lastMeteoriteSpawn = 0;
        const METEORITE_SPAWN_INTERVAL = 1000; // 1 second
        const METEORITES_PER_SPAWN = 1; // Spawn 1 meteorite every second

        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(
                CONFIG.camera.fov,
                window.innerWidth / window.innerHeight,
                CONFIG.camera.near,
                CONFIG.camera.far
            );
            camera.position.set(0, 150, 300);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post-processing (Bloom for Sun)
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.rendering.bloom.strength,
                CONFIG.rendering.bloom.radius,
                CONFIG.rendering.bloom.threshold
            );
            composer.addPass(bloomPass);

            // OrbitControls for smooth camera navigation
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0;      // Allow zoom through planets
            controls.maxDistance = 25000;  // Increased to support outer system bodies (was 5000)
            controls.enablePan = true;
            controls.target.set(0, 0, 0);

            // Load textures and build scene
            loadTextures();

            // Event listeners
            setupEventListeners();

            // Start animation
            animate();
        }

        // ==================== TEXTURE LOADING ====================
        const textureLoader = new THREE.TextureLoader();
        let loadedTextures = 0;
        let totalTextures = 0;
        let priorityTexturesLoaded = 0;
        let priorityTexturesTotal = 0;
        let simulationStarted = false;

        function loadTextures() {
            // Count total textures (including new objects)
            totalTextures = 1 + PLANETS.length + Object.keys(MOON_DATA).length + 1 +
                MINOR_PLANETS.length + TRANS_NEPTUNIAN_OBJECTS.length + OUTER_SYSTEM_BODIES.length;

            // Priority textures: Sun + 8 major planets (Mercury-Neptune) + starfield
            priorityTexturesTotal = 1 + 8 + 1; // starfield + 8 planets + sun

            // Load starfield background (PRIORITY)
            loadTexture('textures/backgrounds/starfield.jpg', (texture) => {
                scene.background = texture;
            }, null, true);

            // Create Sun (PRIORITY)
            createSun(true);

            // Create major planets ONLY (Mercury through Neptune) - PRIORITY
            for (let i = 0; i < 8; i++) {
                createPlanet(PLANETS[i], i, true);
            }

            // Create Pluto and Planet QQ with fallback colors (will load textures later)
            for (let i = 8; i < PLANETS.length; i++) {
                createPlanet(PLANETS[i], i, false);
            }

            // Create all other objects with fallback colors (textures load later)
            MINOR_PLANETS.forEach((bodyData) => {
                createMinorPlanet(bodyData, false);
            });

            TRANS_NEPTUNIAN_OBJECTS.forEach((bodyData) => {
                createMinorPlanet(bodyData, false);
            });

            OUTER_SYSTEM_BODIES.forEach((bodyData) => {
                createMinorPlanet(bodyData, false);
            });

            // Create Asteroid Belt
            createAsteroidBelt();

            // Create Kuiper Belt
            createKuiperBelt();

            // Create Comets
            createComets();

            // Create Shooting Stars
            createShootingStars();

            // Create Black Hole
            createBlackHole();
        }

        function loadSecondaryTextures() {
            // Load Pluto and Planet QQ textures
            for (let i = 8; i < PLANETS.length; i++) {
                const planetData = PLANETS[i];
                const planet = planets[i];
                if (planet && planet.children[0]) {
                    loadTexture(planetData.texture, (texture) => {
                        planet.children[0].material.map = texture;
                        planet.children[0].material.needsUpdate = true;
                    });
                }
            }

            // Load moon textures
            moons.forEach((moon) => {
                if (moon.userData && moon.userData.name) {
                    const moonData = MOON_DATA[moon.userData.name];
                    if (moonData && moonData.texture) {
                        loadTexture(moonData.texture, (texture) => {
                            moon.material.map = texture;
                            moon.material.needsUpdate = true;
                        });
                    }
                }
            });

            // Load minor planet textures
            minorPlanets.forEach((body) => {
                if (body.userData && body.userData.texturePath && body.children[0]) {
                    loadTexture(body.userData.texturePath, (texture) => {
                        body.children[0].material.map = texture;
                        body.children[0].material.needsUpdate = true;
                    });
                }
            });

            // Load TNO textures
            transNeptunianObjects.forEach((body) => {
                if (body.userData && body.userData.texturePath && body.children[0]) {
                    loadTexture(body.userData.texturePath, (texture) => {
                        body.children[0].material.map = texture;
                        body.children[0].material.needsUpdate = true;
                    });
                }
            });

            // Load outer system body textures
            outerSystemBodies.forEach((body) => {
                if (body.userData && body.userData.texturePath && body.children[0]) {
                    loadTexture(body.userData.texturePath, (texture) => {
                        body.children[0].material.map = texture;
                        body.children[0].material.needsUpdate = true;
                    });
                }
            });
        }

        function loadTexture(path, onLoad, onError, isPriority = false) {
            textureLoader.load(
                path,
                (texture) => {
                    loadedTextures++;
                    if (isPriority) {
                        priorityTexturesLoaded++;
                        updateLoadingProgress();
                        checkLoadingComplete();
                    }
                    if (onLoad) onLoad(texture);
                },
                undefined,
                (err) => {
                    // Use fallback color if texture fails
                    loadedTextures++;
                    if (isPriority) {
                        priorityTexturesLoaded++;
                        updateLoadingProgress();
                        checkLoadingComplete();
                    }
                    console.warn(`Failed to load texture: ${path}`);
                    if (onError) onError();
                }
            );
        }

        function updateLoadingProgress() {
            // Only show progress for priority textures (0-100%)
            const progress = Math.min(100, (priorityTexturesLoaded / priorityTexturesTotal) * 100);
            document.getElementById('loading-bar').style.width = progress + '%';
            document.getElementById('loading-text').textContent =
                `Loading textures... ${Math.round(progress)}%`;
        }

        function checkLoadingComplete() {
            // Check if priority textures are loaded (not all textures)
            if (priorityTexturesLoaded >= priorityTexturesTotal && !simulationStarted) {
                simulationStarted = true;
                document.getElementById('loading').classList.add('hidden');
                updateObjectCount();
                // Continue loading secondary textures in background
                loadSecondaryTextures();
            }
        }

        // ==================== CELESTIAL BODY CREATION ====================
        function createSun(isPriority = false) {
            const geometry = new THREE.SphereGeometry(CONFIG.educational.sunRadius, 64, 64);

            loadTexture('textures/sun/sun.jpg', (texture) => {
                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    emissive: 0xffaa00,
                    emissiveIntensity: 1.5,
                    roughness: 1.0,
                    metalness: 0
                });
                sun = new THREE.Mesh(geometry, material);
                scene.add(sun);
                celestialObjects.push({ mesh: sun, name: 'Sun', data: { name: 'Sun', type: 'star' } });

                // Sun light (reduced for educational visibility)
                const sunLight = new THREE.PointLight(0xffffff, 1.0, 3000);
                sunLight.position.set(0, 0, 0);
                scene.add(sunLight);

                // Strong ambient light for educational mode (brighter for dark planets/moons)
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); // Full white at 150% intensity
                scene.add(ambientLight);
            }, () => {
                // Fallback without texture
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffaa00,
                    emissive: 0xffaa00,
                    emissiveIntensity: 2,
                    roughness: 1.0,
                    metalness: 0
                });
                sun = new THREE.Mesh(geometry, material);
                scene.add(sun);
            }, isPriority);
        }

        function createPlanet(planetData, index, isPriority = false) {
            const planetGroup = new THREE.Group();

            // Planet sphere
            const radius = planetData.radius * CONFIG.educational.planetSizeScale;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);

            // Handle special texture filenames
            let texturePath = `textures/planets/${planetData.name.toLowerCase()}.jpg`;
            if (planetData.name === 'Earth') texturePath = 'textures/planets/earth_daymap.jpg';
            if (planetData.name === 'Venus') texturePath = 'textures/planets/venus_surface.jpg';
            if (planetData.name === 'Planet QQ') texturePath = 'textures/planets/qq.jpg';

            // Use awake texture if in awake mode and available
            if (isAwakeMode && AWAKE_TEXTURES[planetData.name]) {
                texturePath = AWAKE_TEXTURES[planetData.name].awake;
            } else if (!isAwakeMode && AWAKE_TEXTURES[planetData.name]) {
                texturePath = AWAKE_TEXTURES[planetData.name].normal;
            }

            // Create material with fallback color immediately
            const material = new THREE.MeshStandardMaterial({
                color: planetData.color || 0x888888,
                roughness: 0.5,
                metalness: 0.2
            });

            const planetMesh = new THREE.Mesh(geometry, material);
            planetGroup.add(planetMesh);

            // Load texture (priority or secondary)
            loadTexture(texturePath, (texture) => {
                material.map = texture;
                material.needsUpdate = true;
            }, null, isPriority);

            // Add rings if applicable
            if (planetData.hasRings) {
                createRings(planetGroup, planetData.name, radius);
            }

            // Create moons (always with fallback, textures load later)
            if (planetData.moons && planetData.moons.length > 0) {
                planetData.moons.forEach(moonName => {
                    createMoon(planetGroup, moonName);
                });
            }

            // Add orbit line
            createOrbitLine(planetData.distance);

            // Store planet data
            planetGroup.userData = {
                ...planetData,
                angle: Math.random() * Math.PI * 2,
                rotationSpeed: (1 / planetData.rotation) * 0.01,
                orbitSpeed: (365 / planetData.orbit) * 0.001
            };

            planets.push(planetGroup);
            scene.add(planetGroup);
            celestialObjects.push({ mesh: planetMesh, name: planetData.name, data: planetData });
        }

        function createMinorPlanet(bodyData, isPriority = false) {
            const bodyGroup = new THREE.Group();

            // Determine geometry based on shape
            const radius = bodyData.radius * CONFIG.educational.planetSizeScale;
            let geometry;

            if (bodyData.shape === 'ellipsoid') {
                // Haumea - ellipsoid shape (2322 x 1704 x 1138 km ratio ‚âà 2.0 x 1.5 x 1.0)
                geometry = new THREE.SphereGeometry(radius, 32, 32);
            } else {
                // Standard sphere for all other bodies
                geometry = new THREE.SphereGeometry(radius, 32, 32);
            }

            // Create material with fallback color immediately
            const material = new THREE.MeshStandardMaterial({
                color: bodyData.color || 0x888888,
                roughness: 0.6,
                metalness: 0.15
            });

            const bodyMesh = new THREE.Mesh(geometry, material);

            // Apply ellipsoid scaling for Haumea
            if (bodyData.shape === 'ellipsoid') {
                bodyMesh.scale.set(2.0, 1.5, 1.0); // Elongated shape
            }

            bodyGroup.add(bodyMesh);

            // Determine texture path - try textures/objects/ first
            const textureName = bodyData.name.toLowerCase().replace(/\s+/g, '_').replace(/\./g, '_');
            let texturePath = `textures/objects/${textureName}.jpg`;

            // Handle special cases for texture filenames
            if (bodyData.name === 'Sedna') texturePath = 'textures/objects/senda.jpeg'; // Typo in filename
            if (bodyData.name === 'PSO J318.5-22') texturePath = 'textures/objects/PSO_J318.5_22.jpg';
            if (bodyData.name === 'WISE 0855-0714') texturePath = 'textures/objects/wise_0855_0714.jpg';
            if (bodyData.name === 'OGLE-2016-BLG-1928') texturePath = 'textures/objects/OGLE-2016-BLG-1928.jpg';
            if (bodyData.name === 'SIMP0136') texturePath = 'textures/objects/SIMP0136.jpg';
            if (bodyData.name === 'Planet X') texturePath = 'textures/objects/planet_x.jpg';
            if (bodyData.name === 'OTS 44') texturePath = 'textures/objects/ots_44.jpg';

            // Store texture path for lazy loading
            bodyGroup.userData.texturePath = texturePath;

            // Load texture (priority or secondary)
            loadTexture(texturePath, (texture) => {
                material.map = texture;
                material.needsUpdate = true;
            }, null, isPriority);

            // Add white line rings if specified
            if (bodyData.rings) {
                createWhiteLineRings(bodyGroup, radius, bodyData.rings, bodyData.shape === 'ellipsoid');
            }

            // Add orbit line
            createOrbitLine(bodyData.distance);

            // Store body data
            bodyGroup.userData = {
                ...bodyData,
                texturePath: texturePath,
                angle: Math.random() * Math.PI * 2,
                rotationSpeed: (1 / bodyData.rotation) * 0.01,
                orbitSpeed: (365 / bodyData.orbit) * 0.001
            };

            // Add to appropriate array based on type
            if (bodyData.type === 'asteroid') {
                minorPlanets.push(bodyGroup);
            } else if (bodyData.type === 'kuiper' || bodyData.type === 'scattered' || bodyData.type === 'oort') {
                transNeptunianObjects.push(bodyGroup);
            } else if (bodyData.type === 'outer') {
                outerSystemBodies.push(bodyGroup);
            }

            scene.add(bodyGroup);
            celestialObjects.push({ mesh: bodyMesh, name: bodyData.name, data: bodyData });
        }

        function createWhiteLineRings(parentGroup, bodyRadius, ringCount, isEllipsoid) {
            for (let i = 0; i < ringCount; i++) {
                // Tighter ring for Haumea (1.6x accounts for 2.0x ellipsoid scaling)
                const ringRadius = bodyRadius * (1.6 + i * 0.4); // Reduced from 2.5 to 1.6
                const segments = 64;

                // Create ring as a line loop
                const ringPoints = [];
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    ringPoints.push(new THREE.Vector3(
                        Math.cos(angle) * ringRadius,
                        0,
                        Math.sin(angle) * ringRadius
                    ));
                }

                const ringGeometry = new THREE.BufferGeometry().setFromPoints(ringPoints);
                const ringMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.8
                });

                const ringMesh = new THREE.Line(ringGeometry, ringMaterial);
                ringMesh.rotation.x = Math.PI / 2; // Horizontal orientation

                // For ellipsoid bodies, scale ring to match
                if (isEllipsoid) {
                    ringMesh.scale.set(2.0, 1.0, 1.0); // Match Haumea's elongation
                }

                parentGroup.add(ringMesh);
            }
        }


        function createAtmosphere(planetMesh, radius, color) {
            const atmosphereGeometry = new THREE.SphereGeometry(radius * 1.15, 32, 32);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                        gl_FragColor = vec4(glowColor, 1.0) * intensity;
                    }
                `,
                uniforms: {
                    glowColor: { value: new THREE.Color(color) }
                },
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            planetMesh.add(atmosphere);
        }

        function createRings(planetGroup, planetName, planetRadius) {
            const ringGeometry = new THREE.RingGeometry(
                planetRadius * 2.2,  // Start further out (was 1.5)
                planetRadius * 3.2,  // Extend wider (was 2.5), thinner span
                64
            );

            // UV mapping for ring texture
            const pos = ringGeometry.attributes.position;
            const uv = ringGeometry.attributes.uv;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const len = Math.sqrt(x * x + y * y);
                uv.setXY(i, len, 0);
            }

            loadTexture(`textures/rings/${planetName.toLowerCase()}_ring.png`, (texture) => {
                const ringMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                // Uranus has vertical rings (perpendicular to orbital plane)
                if (planetName === 'Uranus') {
                    ringMesh.rotation.z = Math.PI / 2; // Vertical orientation
                } else {
                    ringMesh.rotation.x = Math.PI / 2; // Standard horizontal
                }
                planetGroup.add(ringMesh);
            }, () => {
                // Fallback to simple transparent ring
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xaaaaaa,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.4
                });
                const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                if (planetName === 'Uranus') {
                    ringMesh.rotation.z = Math.PI / 2;
                } else {
                    ringMesh.rotation.x = Math.PI / 2;
                }
                planetGroup.add(ringMesh);
            });
        }

        function createMoon(parentGroup, moonName) {
            const moonInfo = MOON_DATA[moonName];
            if (!moonInfo) return;

            const moonGroup = new THREE.Group();
            const geometry = new THREE.SphereGeometry(moonInfo.radius * CONFIG.educational.moonSizeScale, 16, 16);

            // Determine texture path based on awake mode
            let texturePath = `textures/moons/${moonName.toLowerCase()}.jpg`;
            if (isAwakeMode && AWAKE_TEXTURES[moonName]) {
                texturePath = AWAKE_TEXTURES[moonName].awake;
            } else if (!isAwakeMode && AWAKE_TEXTURES[moonName]) {
                texturePath = AWAKE_TEXTURES[moonName].normal;
            }

            loadTexture(texturePath, (texture) => {
                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.6,  // Reduced from 0.9 for brighter appearance
                    metalness: 0.15  // Added for more reflectivity
                });
                const moonMesh = new THREE.Mesh(geometry, material);
                moonGroup.add(moonMesh);

                moonGroup.userData = {
                    name: moonName,
                    angle: Math.random() * Math.PI * 2,
                    distance: moonInfo.distance,
                    orbitSpeed: (1 / moonInfo.orbit) * 0.01
                };

                parentGroup.add(moonGroup);
                moons.push(moonGroup);
                celestialObjects.push({ mesh: moonMesh, name: moonName, data: moonInfo });
            }, () => {
                // Fallback
                const material = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
                const moonMesh = new THREE.Mesh(geometry, material);
                moonGroup.add(moonMesh);
                moonGroup.userData = {
                    name: moonName,
                    angle: Math.random() * Math.PI * 2,
                    distance: moonInfo.distance,
                    orbitSpeed: (1 / moonInfo.orbit) * 0.01
                };
                parentGroup.add(moonGroup);
                moons.push(moonGroup);
            });

            // Add moon orbit line (outside texture callback, always create)
            createMoonOrbitLine(parentGroup, moonInfo.distance);
        }

        function createOrbitLine(distance) {
            const geometry = new THREE.BufferGeometry();
            const points = [];
            for (let i = 0; i <= 128; i++) {
                const angle = (i / 128) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                ));
            }
            geometry.setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x888888,  // Match moon orbit lines
                transparent: true,
                opacity: 0.4      // Match moon orbit lines
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function createMoonOrbitLine(parentGroup, distance) {
            const geometry = new THREE.BufferGeometry();
            const points = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                ));
            }
            geometry.setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x888888,  // Lighter grey for moon orbits
                transparent: true,
                opacity: 0.4
            });
            const line = new THREE.Line(geometry, material);
            parentGroup.add(line); // Add to planet group, not scene
        }

        function createAsteroidBelt() {
            const asteroidGeometry = new THREE.IcosahedronGeometry(0.5, 0);
            const asteroidMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,      // Bright grey for visibility
                emissive: 0x777777,   // Glow against black background
                roughness: 0.9,
                metalness: 0.1
            });

            asteroidBelt = new THREE.InstancedMesh(
                asteroidGeometry,
                asteroidMaterial,
                CONFIG.educational.asteroidCount
            );

            const dummy = new THREE.Object3D();
            const minDist = 400; // Between Mars (315) and Jupiter (540)
            const maxDist = 520;

            for (let i = 0; i < CONFIG.educational.asteroidCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = minDist + Math.random() * (maxDist - minDist);
                const height = (Math.random() - 0.5) * 10;

                dummy.position.set(
                    Math.cos(angle) * distance,
                    height,
                    Math.sin(angle) * distance
                );

                dummy.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                const scale = 0.3 + Math.random() * 1.2;
                dummy.scale.set(scale, scale, scale);

                dummy.updateMatrix();
                asteroidBelt.setMatrixAt(i, dummy.matrix);
            }

            scene.add(asteroidBelt);
        }

        function createKuiperBelt() {
            const asteroidGeometry = new THREE.IcosahedronGeometry(1.5, 0);  // 3x larger (was 0.5)
            const asteroidMaterial = new THREE.MeshStandardMaterial({
                color: 0xb8956a,      // Light brown (was 0xaabbcc bluish-grey)
                emissive: 0x8b7355,   // Darker brown glow (was 0x556677)
                roughness: 0.9,
                metalness: 0.1
            });

            kuiperBelt = new THREE.InstancedMesh(
                asteroidGeometry,
                asteroidMaterial,
                CONFIG.educational.asteroidCount * 4.5  // 3x more objects (was 1.5x)
            );

            const dummy = new THREE.Object3D();
            const minDist = 1550; // Just beyond Neptune (1500)
            const maxDist = 1820; // Just before Pluto (1860)

            for (let i = 0; i < CONFIG.educational.asteroidCount * 4.5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = minDist + Math.random() * (maxDist - minDist);
                const height = (Math.random() - 0.5) * 15; // Slightly thicker belt

                dummy.position.set(
                    Math.cos(angle) * distance,
                    height,
                    Math.sin(angle) * distance
                );

                dummy.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                const scale = 0.3 + Math.random() * 1.2;
                dummy.scale.set(scale, scale, scale);

                dummy.updateMatrix();
                kuiperBelt.setMatrixAt(i, dummy.matrix);
            }

            scene.add(kuiperBelt);
        }

        function createComets() {
            const cometCount = 3 + Math.floor(Math.random() * 3); // 3-5 comets

            for (let i = 0; i < cometCount; i++) {
                const comet = {
                    // Elliptical orbit parameters
                    semiMajorAxis: 800 + Math.random() * 1200, // Random ellipse size
                    eccentricity: 0.7 + Math.random() * 0.25,  // Highly elliptical
                    angle: Math.random() * Math.PI * 2,
                    inclination: (Math.random() - 0.5) * 0.5,  // Tilted orbits
                    speed: ['fast', 'medium', 'slow'][Math.floor(Math.random() * 3)],
                    speedMultiplier: 0,
                    color: [0xffffff, 0xaaddff, 0xffffaa][Math.floor(Math.random() * 3)],

                    // Visual elements
                    nucleus: null,
                    tail: null,
                    position: new THREE.Vector3()
                };

                // Set speed based on category
                switch (comet.speed) {
                    case 'fast': comet.speedMultiplier = 0.003; break;
                    case 'medium': comet.speedMultiplier = 0.0015; break;
                    case 'slow': comet.speedMultiplier = 0.0008; break;
                }

                // Create tiny nucleus (mostly invisible, focus on tail)
                const nucleusGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const nucleusMaterial = new THREE.MeshStandardMaterial({
                    color: comet.color,
                    emissive: comet.color,
                    emissiveIntensity: 0.5
                });
                comet.nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
                scene.add(comet.nucleus);

                // Create tail as line (will be updated every frame)
                const tailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(60); // 20 points * 3 coords
                tailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const tailMaterial = new THREE.LineBasicMaterial({
                    color: comet.color,
                    transparent: true,
                    opacity: 0.6
                });
                comet.tail = new THREE.Line(tailGeometry, tailMaterial);
                scene.add(comet.tail);

                comets.push(comet);
            }
        }

        function createShootingStars() {
            const starCount = 20; // Fast meteors

            for (let i = 0; i < starCount; i++) {
                const star = {
                    // Linear trajectory (not orbital)
                    position: new THREE.Vector3(
                        (Math.random() - 0.5) * 3000,
                        (Math.random() - 0.5) * 500,
                        (Math.random() - 0.5) * 3000
                    ),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 20
                    ),
                    speed: 15 + Math.random() * 35, // Very fast
                    color: [0xffffff, 0xaaddff, 0xffffcc][Math.floor(Math.random() * 3)],

                    nucleus: null,
                    tail: null
                };

                // Tiny bright nucleus
                const nucleusGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const nucleusMaterial = new THREE.MeshStandardMaterial({
                    color: star.color,
                    emissive: star.color,
                    emissiveIntensity: 1.0
                });
                star.nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
                scene.add(star.nucleus);

                // Short tail pointing in direction of motion
                const tailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(30); // 10 points
                tailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const tailMaterial = new THREE.LineBasicMaterial({
                    color: star.color,
                    transparent: true,
                    opacity: 0.7
                });
                star.tail = new THREE.Line(tailGeometry, tailMaterial);
                scene.add(star.tail);

                shootingStars.push(star);
            }
        }

        // ==================== BLACK HOLE CREATION ====================
        function createBlackHole() {
            const rs = 2 * BH_CONFIG.G * BH_CONFIG.M / (BH_CONFIG.c * BH_CONFIG.c);
            const rIn = BH_CONFIG.diskInner * rs;
            const rOut = BH_CONFIG.diskOuter * rs;
            const N = BH_CONFIG.particleCount;

            // Create event horizon sphere (70% smaller than before)
            const bhGeometry = new THREE.SphereGeometry(rs * BH_CONFIG.scale * 0.018, 32, 16);
            const bhMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            blackHoleSphere = new THREE.Mesh(bhGeometry, bhMaterial);
            blackHoleSphere.position.copy(BH_CONFIG.position);
            scene.add(blackHoleSphere);

            // Photon ring and glow removed - too large and potentially confusing for students


            // Initialize particle disk
            const positions = new Float32Array(N * 3);
            const colors = new Float32Array(N * 3);
            bhParticleState = new Float32Array(N * 3);
            bhParticleVel = new Float32Array(N * 3);

            for (let i = 0; i < N; i++) {
                const j = i * 3;
                // Bias distribution toward inner radius (more dense near black hole)
                const u = Math.pow(Math.random(), 2.5);  // Power law distribution
                const r = Math.sqrt((1 - u) * rIn * rIn + u * rOut * rOut);
                const ang = Math.random() * Math.PI * 2;
                const x = r * Math.cos(ang);
                const z = r * Math.sin(ang);
                const y = (Math.random() - 0.5) * 0.02 * r;

                bhParticleState[j + 0] = x;
                bhParticleState[j + 1] = y;
                bhParticleState[j + 2] = z;

                // Keplerian velocity
                const vphi = Math.sqrt(BH_CONFIG.G * BH_CONFIG.M * r) / (r - rs);
                bhParticleVel[j + 0] = -vphi * Math.sin(ang);
                bhParticleVel[j + 1] = 0;
                bhParticleVel[j + 2] = vphi * Math.cos(ang);

                // Apply scale and position
                const scl = BH_CONFIG.scale * 0.02;
                positions[j + 0] = x * scl + BH_CONFIG.position.x;
                positions[j + 1] = y * scl + BH_CONFIG.position.y;
                positions[j + 2] = z * scl + BH_CONFIG.position.z;

                // Color gradient with radial fade: inner bright, outer fades
                const t = (r - rIn) / (rOut - rIn);
                const fadeOpacity = 1.0 - t * 0.8;  // Inner = 1.0, outer = 0.2
                const inner = 0xFFF1D4, outer = 0x8B5A3C;
                const r1 = (inner >> 16) & 255, g1 = (inner >> 8) & 255, b1 = inner & 255;
                const r2 = (outer >> 16) & 255, g2 = (outer >> 8) & 255, b2 = outer & 255;
                colors[j + 0] = ((r1 + (r2 - r1) * t) / 255) * fadeOpacity;
                colors[j + 1] = ((g1 + (g2 - g1) * t) / 255) * fadeOpacity;
                colors[j + 2] = ((b1 + (b2 - b1) * t) / 255) * fadeOpacity;
            }

            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: BH_CONFIG.particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthTest: true,
                depthWrite: true
            });

            blackHoleParticles = new THREE.Points(particleGeometry, particleMaterial);
            blackHoleParticles.renderOrder = 1;
            scene.add(blackHoleParticles);
        }

        // ==================== BLACK HOLE PHYSICS UPDATE ====================
        function updateBlackHole() {
            if (!blackHoleParticles || !bhParticleState || !bhParticleVel) return;

            const positions = blackHoleParticles.geometry.attributes.position.array;
            const colors = blackHoleParticles.geometry.attributes.color.array;
            const N = bhParticleState.length / 3;
            const rs = 2 * BH_CONFIG.G * BH_CONFIG.M / (BH_CONFIG.c * BH_CONFIG.c);
            const dt = 0.0045 * 20.0 * 5.2 * timeScale; // 30% faster (was 4.0, now 5.2)
            const scl = BH_CONFIG.scale * 0.02;

            for (let i = 0; i < N; i++) {
                const j = i * 3;

                // Current position and acceleration
                const rx = bhParticleState[j + 0];
                const ry = bhParticleState[j + 1];
                const rz = bhParticleState[j + 2];
                const r = Math.sqrt(rx * rx + ry * ry + rz * rz);

                if (r <= rs * 1.05 || !isFinite(r)) {
                    // Respawn particle in disk
                    const rIn = BH_CONFIG.diskInner * rs;
                    const rOut = BH_CONFIG.diskOuter * rs;
                    const u = Math.random();
                    const rNew = Math.sqrt((1 - u) * rIn * rIn + u * rOut * rOut);
                    const ang = Math.random() * Math.PI * 2;
                    bhParticleState[j + 0] = rNew * Math.cos(ang);
                    bhParticleState[j + 1] = (Math.random() - 0.5) * 0.02 * rNew;
                    bhParticleState[j + 2] = rNew * Math.sin(ang);
                    const vphi = Math.sqrt(BH_CONFIG.G * BH_CONFIG.M * rNew) / (rNew - rs);
                    bhParticleVel[j + 0] = -vphi * Math.sin(ang);
                    bhParticleVel[j + 1] = 0;
                    bhParticleVel[j + 2] = vphi * Math.cos(ang);
                    continue;
                }

                const aMag = BH_CONFIG.G * BH_CONFIG.M / ((r - rs) * (r - rs));
                const ux = rx / r, uy = ry / r, uz = rz / r;

                // Velocity Verlet: half-step velocity
                bhParticleVel[j + 0] += -aMag * ux * dt * 0.5;
                bhParticleVel[j + 1] += -aMag * uy * dt * 0.5;
                bhParticleVel[j + 2] += -aMag * uz * dt * 0.5;

                // Position update
                bhParticleState[j + 0] += bhParticleVel[j + 0] * dt;
                bhParticleState[j + 1] += bhParticleVel[j + 1] * dt;
                bhParticleState[j + 2] += bhParticleVel[j + 2] * dt;

                // New acceleration
                const r2x = bhParticleState[j + 0];
                const r2y = bhParticleState[j + 1];
                const r2z = bhParticleState[j + 2];
                const r2 = Math.sqrt(r2x * r2x + r2y * r2y + r2z * r2z);
                const aMag2 = BH_CONFIG.G * BH_CONFIG.M / ((r2 - rs) * (r2 - rs));
                const ux2 = r2x / r2, uy2 = r2y / r2, uz2 = r2z / r2;

                // Velocity second half-step
                bhParticleVel[j + 0] += -aMag2 * ux2 * dt * 0.5;
                bhParticleVel[j + 1] += -aMag2 * uy2 * dt * 0.5;
                bhParticleVel[j + 2] += -aMag2 * uz2 * dt * 0.5;

                // Update rendered positions with tilt
                const xw = bhParticleState[j + 0] * scl;
                const yw = bhParticleState[j + 1] * scl;
                const zw = bhParticleState[j + 2] * scl;
                const th = BH_CONFIG.diskTiltDeg * Math.PI / 180;
                const cy = Math.cos(th), sy = Math.sin(th);
                const y2 = cy * yw - sy * zw;
                const z2 = sy * yw + cy * zw;
                positions[j + 0] = xw + BH_CONFIG.position.x;
                positions[j + 1] = y2 + BH_CONFIG.position.y;
                positions[j + 2] = z2 + BH_CONFIG.position.z;

                // Relativistic beaming for brightness
                const vx = bhParticleVel[j + 0], vy = bhParticleVel[j + 1], vz = bhParticleVel[j + 2];
                const vmag = Math.sqrt(vx * vx + vy * vy + vz * vz);
                const beta = Math.min(0.99, vmag / BH_CONFIG.c);
                const vhatx = vx / (vmag || 1e-9), vhaty = vy / (vmag || 1e-9), vhatz = vz / (vmag || 1e-9);

                const dx = camera.position.x - positions[j + 0];
                const dy = camera.position.y - positions[j + 1];
                const dz = camera.position.z - positions[j + 2];
                const dn = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1e-9;
                const cosT = (vhatx * dx + vhaty * dy + vhatz * dz) / dn;

                const D = 1.0 / Math.max(0.05, (1.0 - beta * cosT));
                const boost = Math.min(6.0, Math.max(0.4, Math.pow(D, BH_CONFIG.beamingPower)));

                // Apply boost to base color with radial fade
                const rIn = BH_CONFIG.diskInner * rs;
                const rOut = BH_CONFIG.diskOuter * rs;
                const t = Math.min(1, Math.max(0, (r2 - rIn) / (rOut - rIn)));

                // Inner particles glow brighter, outer fade to oblivion
                const fadeOpacity = 1.0 - t * 0.8;  // Inner = 1.0, outer = 0.2
                const innerBoost = 1.0 + (1.0 - t) * 0.5;  // Inner particles 1.5x brighter

                const inner = 0xFFF1D4, outer = 0x8B5A3C;
                const r1 = (inner >> 16) & 255, g1 = (inner >> 8) & 255, b1 = inner & 255;
                const r2c = (outer >> 16) & 255, g2 = (outer >> 8) & 255, b2 = outer & 255;
                colors[j + 0] = Math.min(1, ((r1 + (r2c - r1) * t) / 255) * boost * fadeOpacity * innerBoost);
                colors[j + 1] = Math.min(1, ((g1 + (g2 - g1) * t) / 255) * boost * fadeOpacity * innerBoost);
                colors[j + 2] = Math.min(1, ((b1 + (b2 - b1) * t) / 255) * boost * fadeOpacity * innerBoost);
            }

            blackHoleParticles.geometry.attributes.position.needsUpdate = true;
            blackHoleParticles.geometry.attributes.color.needsUpdate = true;
        }

        // ==================== METEORITE SYSTEM ====================
        function spawnMeteorite() {
            const rs = 2 * BH_CONFIG.G * BH_CONFIG.M / (BH_CONFIG.c * BH_CONFIG.c);
            const spawnDistance = BH_CONFIG.diskOuter * rs * 3; // Spawn outside the disk

            // Random position around black hole
            const theta = Math.random() * Math.PI * 2;
            const phi = (Math.random() - 0.5) * Math.PI * 0.5; // Some vertical variation

            const x = spawnDistance * Math.cos(theta) * Math.cos(phi);
            const y = spawnDistance * Math.sin(phi);
            const z = spawnDistance * Math.sin(theta) * Math.cos(phi);

            // Create meteorite mesh (4x particle size = 1.0)
            const geometry = new THREE.SphereGeometry(1.0, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0xFF6B35, // Orange-red color
                emissive: 0xFF4500,
                emissiveIntensity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);

            const scl = BH_CONFIG.scale * 0.02;
            mesh.position.set(
                x * scl + BH_CONFIG.position.x,
                y * scl + BH_CONFIG.position.y,
                z * scl + BH_CONFIG.position.z
            );

            scene.add(mesh);

            // Create light trail
            const trailLength = 20;
            const trailPositions = new Float32Array(trailLength * 3);
            for (let i = 0; i < trailLength; i++) {
                trailPositions[i * 3 + 0] = mesh.position.x;
                trailPositions[i * 3 + 1] = mesh.position.y;
                trailPositions[i * 3 + 2] = mesh.position.z;
            }
            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            const trailMaterial = new THREE.LineBasicMaterial({
                color: 0xFF6B35,
                transparent: true,
                opacity: 0.6
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            meteorites.push({
                mesh: mesh,
                trail: trail,
                trailPositions: trailPositions,
                trailIndex: 0,
                localPos: { x, y, z }, // Position relative to black hole center
                velocity: { x: 0, y: 0, z: 0 },
                lifetime: 0
            });
        }

        function updateMeteorites(deltaTime) {
            const rs = 2 * BH_CONFIG.G * BH_CONFIG.M / (BH_CONFIG.c * BH_CONFIG.c);
            const scl = BH_CONFIG.scale * 0.02;

            for (let i = meteorites.length - 1; i >= 0; i--) {
                const met = meteorites[i];
                met.lifetime += deltaTime;

                // Calculate distance from black hole center
                const r = Math.sqrt(met.localPos.x ** 2 + met.localPos.y ** 2 + met.localPos.z ** 2);

                // Remove if reached event horizon or too old
                if (r <= rs * 1.1 || met.lifetime > 30) {
                    scene.remove(met.mesh);
                    scene.remove(met.trail);
                    met.mesh.geometry.dispose();
                    met.mesh.material.dispose();
                    met.trail.geometry.dispose();
                    met.trail.material.dispose();
                    meteorites.splice(i, 1);
                    continue;
                }

                // Gravitational acceleration toward black hole
                const aMag = BH_CONFIG.G * BH_CONFIG.M / ((r - rs) ** 2);
                const ux = -met.localPos.x / r;
                const uy = -met.localPos.y / r;
                const uz = -met.localPos.z / r;

                // Update velocity (50x multiplier for visible motion)
                met.velocity.x += aMag * ux * deltaTime * 50;
                met.velocity.y += aMag * uy * deltaTime * 50;
                met.velocity.z += aMag * uz * deltaTime * 50;

                // Update position
                met.localPos.x += met.velocity.x * deltaTime;
                met.localPos.y += met.velocity.y * deltaTime;
                met.localPos.z += met.velocity.z * deltaTime;

                // Update mesh position
                met.mesh.position.set(
                    met.localPos.x * scl + BH_CONFIG.position.x,
                    met.localPos.y * scl + BH_CONFIG.position.y,
                    met.localPos.z * scl + BH_CONFIG.position.z
                );

                // Update trail
                met.trailIndex = (met.trailIndex + 1) % (met.trailPositions.length / 3);
                met.trailPositions[met.trailIndex * 3 + 0] = met.mesh.position.x;
                met.trailPositions[met.trailIndex * 3 + 1] = met.mesh.position.y;
                met.trailPositions[met.trailIndex * 3 + 2] = met.mesh.position.z;
                met.trail.geometry.attributes.position.needsUpdate = true;

                // Brighten as it gets closer (heating up)
                const brightness = Math.min(2.0, 1.0 + (1.0 - r / (BH_CONFIG.diskOuter * rs * 3)));
                met.mesh.material.emissiveIntensity = 0.8 * brightness;
            }
        }

        // ==================== ANIMATION & UPDATES ====================
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = 0.016; // ~60fps target

            if (!isPaused) {
                elapsedTime += deltaTime * timeScale;

                // Update planets
                planets.forEach(planet => {
                    // Orbital motion
                    planet.userData.angle += planet.userData.orbitSpeed * timeScale;
                    planet.position.x = Math.cos(planet.userData.angle) * planet.userData.distance;
                    planet.position.z = Math.sin(planet.userData.angle) * planet.userData.distance;

                    // Rotation
                    if (planet.children[0]) {
                        planet.children[0].rotation.y += planet.userData.rotationSpeed * timeScale;
                    }

                    // Update moons
                    planet.children.forEach(child => {
                        if (child.userData && child.userData.name && MOON_DATA[child.userData.name]) {
                            child.userData.angle += child.userData.orbitSpeed * timeScale;
                            child.position.x = Math.cos(child.userData.angle) * child.userData.distance;
                            child.position.z = Math.sin(child.userData.angle) * child.userData.distance;
                        }
                    });
                });

                // Update minor planets (Ceres)
                minorPlanets.forEach(body => {
                    body.userData.angle += body.userData.orbitSpeed * timeScale;
                    body.position.x = Math.cos(body.userData.angle) * body.userData.distance;
                    body.position.z = Math.sin(body.userData.angle) * body.userData.distance;

                    if (body.children[0]) {
                        body.children[0].rotation.y += body.userData.rotationSpeed * timeScale;
                    }
                });

                // Update trans-Neptunian objects
                transNeptunianObjects.forEach(body => {
                    body.userData.angle += body.userData.orbitSpeed * timeScale;
                    body.position.x = Math.cos(body.userData.angle) * body.userData.distance;
                    body.position.z = Math.sin(body.userData.angle) * body.userData.distance;

                    // Rotate all bodies except Haumea (keep ellipsoid stationary)
                    if (body.children[0] && body.userData.name !== 'Haumea') {
                        body.children[0].rotation.y += body.userData.rotationSpeed * timeScale;
                    }
                });

                // Update outer system bodies
                outerSystemBodies.forEach(body => {
                    body.userData.angle += body.userData.orbitSpeed * timeScale;
                    body.position.x = Math.cos(body.userData.angle) * body.userData.distance;
                    body.position.z = Math.sin(body.userData.angle) * body.userData.distance;

                    if (body.children[0]) {
                        body.children[0].rotation.y += body.userData.rotationSpeed * timeScale;
                    }
                });

                // Rotate asteroid belt slightly
                if (asteroidBelt) {
                    asteroidBelt.rotation.y += 0.0001 * timeScale;
                }

                // Rotate Kuiper belt slightly (slower than asteroid belt)
                if (kuiperBelt) {
                    kuiperBelt.rotation.y += 0.00005 * timeScale;
                }

                // Update black hole physics
                updateBlackHole();

                // Spawn meteorites periodically (every 10 seconds)
                const currentTime = Date.now();
                if (currentTime - lastMeteoriteSpawn > METEORITE_SPAWN_INTERVAL) {
                    for (let i = 0; i < METEORITES_PER_SPAWN; i++) {
                        spawnMeteorite();
                    }
                    lastMeteoriteSpawn = currentTime;
                }

                // Update meteorites
                updateMeteorites(deltaTime * timeScale);

                // Update comets
                comets.forEach(comet => {
                    // Update elliptical orbit position
                    comet.angle += comet.speedMultiplier * timeScale;

                    // Calculate position on ellipse
                    const a = comet.semiMajorAxis; // Semi-major axis
                    const e = comet.eccentricity;   // Eccentricity
                    const r = (a * (1 - e * e)) / (1 + e * Math.cos(comet.angle));

                    // Position with inclination
                    comet.position.x = r * Math.cos(comet.angle);
                    comet.position.y = r * Math.sin(comet.angle) * Math.sin(comet.inclination);
                    comet.position.z = r * Math.sin(comet.angle) * Math.cos(comet.inclination);

                    // Update nucleus position
                    comet.nucleus.position.copy(comet.position);

                    // Calculate tail direction (away from sun)
                    const toSun = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), comet.position);
                    const sunDistance = toSun.length();
                    const tailDirection = toSun.normalize().multiplyScalar(-1); // Away from sun

                    // Tail length scales with proximity to sun (longer when closer)
                    const baseTailLength = 5;  // Very short for subtle decoration (was 25)
                    const proximityFactor = Math.max(1.2, Math.min(2.5, 3000 / sunDistance));
                    const tailLength = baseTailLength * proximityFactor;

                    // Update tail geometry
                    const positions = comet.tail.geometry.attributes.position.array;
                    for (let i = 0; i < 20; i++) {
                        const t = i / 19;
                        const offset = tailDirection.clone().multiplyScalar(t * tailLength);
                        const spread = t * 10; // Tail spreads out

                        positions[i * 3] = comet.position.x + offset.x + (Math.random() - 0.5) * spread;
                        positions[i * 3 + 1] = comet.position.y + offset.y + (Math.random() - 0.5) * spread;
                        positions[i * 3 + 2] = comet.position.z + offset.z + (Math.random() - 0.5) * spread;
                    }
                    comet.tail.geometry.attributes.position.needsUpdate = true;

                    // Update tail opacity based on sun proximity (brighter when closer)
                    comet.tail.material.opacity = Math.min(0.8, 0.3 + (proximityFactor - 2) / 4 * 0.5);
                });

                // Update shooting stars
                shootingStars.forEach(star => {
                    // Move linearly
                    star.position.add(star.velocity.clone().multiplyScalar(timeScale));
                    star.nucleus.position.copy(star.position);

                    // Update tail (points opposite to velocity)
                    const tailDirection = star.velocity.clone().normalize().multiplyScalar(-1);
                    const tailLength = 15; // Short streaks

                    const positions = star.tail.geometry.attributes.position.array;
                    for (let i = 0; i < 10; i++) {
                        const t = i / 9;
                        const offset = tailDirection.clone().multiplyScalar(t * tailLength);

                        positions[i * 3] = star.position.x + offset.x;
                        positions[i * 3 + 1] = star.position.y + offset.y;
                        positions[i * 3 + 2] = star.position.z + offset.z;
                    }
                    star.tail.geometry.attributes.position.needsUpdate = true;

                    // Respawn if too far from origin
                    if (star.position.length() > 2000) {
                        star.position.set(
                            (Math.random() - 0.5) * 3000,
                            (Math.random() - 0.5) * 500,
                            (Math.random() - 0.5) * 3000
                        );
                        star.velocity.set(
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 20
                        );
                    }
                });

                // Update camera position based on WASD input
                updateCameraMovement();

                // Update active asteroids
                activeAsteroids.forEach((asteroid, index) => {
                    asteroid.mesh.position.add(asteroid.velocity.clone().multiplyScalar(timeScale));
                    asteroid.mesh.rotation.x += 0.1;
                    asteroid.mesh.rotation.y += 0.15;

                    // Raycast for collision detection
                    const raycaster = new THREE.Raycaster();
                    const direction = asteroid.velocity.clone().normalize();
                    raycaster.set(asteroid.mesh.position, direction);

                    // Check collision with all celestial objects
                    const meshes = celestialObjects.map(obj => obj.mesh);
                    const intersects = raycaster.intersectObjects(meshes);

                    // Check if we hit something within reasonable range
                    const moveDistance = asteroid.velocity.length() * timeScale;
                    if (intersects.length > 0 && intersects[0].distance < moveDistance * 5) {
                        // Create explosion at impact point
                        createExplosion(intersects[0].point);

                        // Remove asteroid and tail
                        scene.remove(asteroid.mesh);
                        scene.remove(asteroid.tail);
                        activeAsteroids.splice(index, 1);
                    }

                    // Update tail
                    const tailDirection = asteroid.velocity.clone().normalize().multiplyScalar(-1);
                    const tailPositions = asteroid.tail.geometry.attributes.position.array;
                    for (let i = 0; i < 10; i++) {
                        const t = i / 9;
                        const offset = tailDirection.clone().multiplyScalar(t * 20);
                        tailPositions[i * 3] = asteroid.mesh.position.x + offset.x;
                        tailPositions[i * 3 + 1] = asteroid.mesh.position.y + offset.y;
                        tailPositions[i * 3 + 2] = asteroid.mesh.position.z + offset.z;
                    }
                    asteroid.tail.geometry.attributes.position.needsUpdate = true;
                });
                // Update explosions
                explosions.forEach((explosion, index) => {
                    explosion.life++;
                    const progress = explosion.life / explosion.maxLife;

                    // Fade out and scale up
                    explosion.sprite.material.opacity = 1.0 - progress;
                    explosion.sprite.scale.multiplyScalar(1.02);

                    // Remove when done
                    if (explosion.life >= explosion.maxLife) {
                        scene.remove(explosion.sprite);
                        explosions.splice(index, 1);
                    }
                });
            }

            // Update OrbitControls
            controls.update();

            // Update proximity labels
            updateProximityLabels();

            // Update FPS counter
            updatePerformance();

            // Render
            composer.render();
        }

        function updateProximityLabels() {
            // Show planet names when camera is close
            planets.forEach((planet, index) => {
                const distance = camera.position.distanceTo(planet.position);
                const visibilityThreshold = planet.userData.radius * 15; // Show when close

                if (distance < visibilityThreshold) {
                    // Project planet position to screen
                    const vector = planet.position.clone();
                    vector.project(camera);

                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                    // Create or update label
                    if (!planetLabels[index]) {
                        const label = document.createElement('div');
                        label.style.position = 'absolute';
                        label.style.color = 'white';
                        label.style.fontSize = '14px';
                        label.style.fontWeight = 'bold';
                        label.style.pointerEvents = 'none';
                        label.style.textShadow = '1px 1px 2px black';
                        label.style.zIndex = '1000';
                        label.textContent = planet.userData.name;
                        document.body.appendChild(label);
                        planetLabels[index] = label;
                    }

                    planetLabels[index].style.left = x + 'px';
                    planetLabels[index].style.top = (y - 20) + 'px';
                    planetLabels[index].style.display = 'block';
                } else {
                    if (planetLabels[index]) {
                        planetLabels[index].style.display = 'none';
                    }
                }
            });

            // Show moon names when camera is close
            moons.forEach((moon, index) => {
                if (!moon.userData || !moon.userData.name) return;

                const moonWorldPos = new THREE.Vector3();
                moon.getWorldPosition(moonWorldPos);
                const distance = camera.position.distanceTo(moonWorldPos);
                const visibilityThreshold = (MOON_DATA[moon.userData.name]?.radius || 1) * 20;

                if (distance < visibilityThreshold) {
                    const vector = moonWorldPos.clone();
                    vector.project(camera);

                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                    const labelKey = 'moon_' + index;
                    if (!planetLabels[labelKey]) {
                        const label = document.createElement('div');
                        label.style.position = 'absolute';
                        label.style.color = 'white';
                        label.style.fontSize = '12px'; // Smaller for moons
                        label.style.fontWeight = 'normal';
                        label.style.pointerEvents = 'none';
                        label.style.textShadow = '1px 1px 2px black';
                        label.style.zIndex = '999';
                        label.textContent = moon.userData.name;
                        document.body.appendChild(label);
                        planetLabels[labelKey] = label;
                    }

                    planetLabels[labelKey].style.left = x + 'px';
                    planetLabels[labelKey].style.top = (y - 15) + 'px';
                    planetLabels[labelKey].style.display = 'block';
                } else {
                    const labelKey = 'moon_' + index;
                    if (planetLabels[labelKey]) {
                        planetLabels[labelKey].style.display = 'none';
                    }
                }
            });

            // Show minor planet names when camera is close
            minorPlanets.forEach((body, index) => {
                const distance = camera.position.distanceTo(body.position);
                const visibilityThreshold = body.userData.radius * 15;

                const labelKey = 'minor_' + index;
                if (distance < visibilityThreshold) {
                    const vector = body.position.clone();
                    vector.project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                    if (!planetLabels[labelKey]) {
                        const label = document.createElement('div');
                        label.style.position = 'absolute';
                        label.style.color = 'white';
                        label.style.fontSize = '14px';
                        label.style.fontWeight = 'bold';
                        label.style.pointerEvents = 'none';
                        label.style.textShadow = '1px 1px 2px black';
                        label.style.zIndex = '999';
                        label.textContent = body.userData.name;
                        document.body.appendChild(label);
                        planetLabels[labelKey] = label;
                    }

                    planetLabels[labelKey].style.left = x + 'px';
                    planetLabels[labelKey].style.top = (y - 15) + 'px';
                    planetLabels[labelKey].style.display = 'block';
                } else {
                    if (planetLabels[labelKey]) {
                        planetLabels[labelKey].style.display = 'none';
                    }
                }
            });

            // Show TNO names when camera is close
            transNeptunianObjects.forEach((body, index) => {
                const distance = camera.position.distanceTo(body.position);
                const visibilityThreshold = body.userData.radius * 15;

                const labelKey = 'tno_' + index;
                if (distance < visibilityThreshold) {
                    const vector = body.position.clone();
                    vector.project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                    if (!planetLabels[labelKey]) {
                        const label = document.createElement('div');
                        label.style.position = 'absolute';
                        label.style.color = 'white';
                        label.style.fontSize = '14px';
                        label.style.fontWeight = 'bold';
                        label.style.pointerEvents = 'none';
                        label.style.textShadow = '1px 1px 2px black';
                        label.style.zIndex = '999';
                        label.textContent = body.userData.name;
                        document.body.appendChild(label);
                        planetLabels[labelKey] = label;
                    }

                    planetLabels[labelKey].style.left = x + 'px';
                    planetLabels[labelKey].style.top = (y - 15) + 'px';
                    planetLabels[labelKey].style.display = 'block';
                } else {
                    if (planetLabels[labelKey]) {
                        planetLabels[labelKey].style.display = 'none';
                    }
                }
            });

            // Show outer system body names when camera is close
            outerSystemBodies.forEach((body, index) => {
                const distance = camera.position.distanceTo(body.position);
                const visibilityThreshold = body.userData.radius * 15;

                const labelKey = 'outer_' + index;
                if (distance < visibilityThreshold) {
                    const vector = body.position.clone();
                    vector.project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

                    if (!planetLabels[labelKey]) {
                        const label = document.createElement('div');
                        label.style.position = 'absolute';
                        label.style.color = 'white';
                        label.style.fontSize = '14px';
                        label.style.fontWeight = 'bold';
                        label.style.pointerEvents = 'none';
                        label.style.textShadow = '1px 1px 2px black';
                        label.style.zIndex = '999';
                        label.textContent = body.userData.name;
                        document.body.appendChild(label);
                        planetLabels[labelKey] = label;
                    }

                    planetLabels[labelKey].style.left = x + 'px';
                    planetLabels[labelKey].style.top = (y - 15) + 'px';
                    planetLabels[labelKey].style.display = 'block';
                } else {
                    if (planetLabels[labelKey]) {
                        planetLabels[labelKey].style.display = 'none';
                    }
                }
            });
        }

        function updatePerformance() {
            frameCount++;
            const now = performance.now();
            if (now >= lastTime + 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        function updateObjectCount() {
            const total = 1 + planets.length + moons.length +
                (asteroidBelt ? CONFIG.educational.asteroidCount : 0) +
                (kuiperBelt ? CONFIG.educational.asteroidCount * 4.5 : 0);
            document.getElementById('objects').textContent = total;
        }

        // ==================== EXPLOSION EFFECTS ====================
        function createExplosion(position) {
            // Create small yellow flash sphere at impact point
            const flashGeometry = new THREE.SphereGeometry(5, 16, 16);  // Small flash
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 3.0,  // Bright flash
                transparent: true,
                opacity: 1.0
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(position);
            scene.add(flash);

            explosions.push({
                sprite: flash,
                life: 0,
                maxLife: 15  // Quick flash (was 60)
            });
        }

        // ==================== CAMERA MOVEMENT ====================
        function updateCameraMovement() {
            if (!keyStates.w && !keyStates.a && !keyStates.s && !keyStates.d && !keyStates.space && !keyStates.shift) {
                return; // No movement keys pressed
            }

            const speed = moveSpeed * (keyStates.shift ? boostMultiplier : 1.0);

            // Get camera's forward and right vectors
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            const up = new THREE.Vector3(0, 1, 0);

            // Calculate movement vector
            const movement = new THREE.Vector3();

            if (keyStates.w) movement.add(forward.clone().multiplyScalar(speed));
            if (keyStates.s) movement.add(forward.clone().multiplyScalar(-speed));
            if (keyStates.a) movement.add(right.clone().multiplyScalar(-speed));
            if (keyStates.d) movement.add(right.clone().multiplyScalar(speed));
            if (keyStates.space) movement.add(up.clone().multiplyScalar(speed));
            if (keyStates.shift && !keyStates.w && !keyStates.s && !keyStates.a && !keyStates.d) {
                // Shift alone moves down
                movement.add(up.clone().multiplyScalar(-speed));
            }

            // Apply movement to camera and controls target
            camera.position.add(movement);
            controls.target.add(movement);
        }

        // ==================== EVENT LISTENERS ====================
        function setupEventListeners() {
            // WASD flight controls - keydown
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w') keyStates.w = true;
                if (key === 'a') keyStates.a = true;
                if (key === 's') keyStates.s = true;
                if (key === 'd') keyStates.d = true;
                if (key === ' ') keyStates.space = true;
                if (e.shiftKey) keyStates.shift = true;

                // Number keys for quick planet focus (1-9 for Pluto)
                switch (e.key) {
                    case '1': case '2': case '3': case '4':
                    case '5': case '6': case '7': case '8': case '9':
                        const planetIndex = parseInt(e.key) - 1;
                        if (planets[planetIndex]) {
                            focusPlanet(planets[planetIndex]);
                        }
                        break;
                }
            });

            // WASD flight controls - keyup
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w') keyStates.w = false;
                if (key === 'a') keyStates.a = false;
                if (key === 's') keyStates.s = false;
                if (key === 'd') keyStates.d = false;
                if (key === ' ') keyStates.space = false;
                if (!e.shiftKey) keyStates.shift = false;
            });

            // Click planet to fly to it
            renderer.domElement.addEventListener('click', (event) => {
                // Only if not dragging (OrbitControls)
                if (event.button === 0) {
                    const raycaster = new THREE.Raycaster();
                    const mouse = new THREE.Vector2();

                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);

                    // Check intersections with celestial objects
                    const meshes = celestialObjects.map(obj => obj.mesh);
                    const intersects = raycaster.intersectObjects(meshes);

                    if (intersects.length > 0) {
                        const clicked = celestialObjects.find(obj => obj.mesh === intersects[0].object);
                        if (clicked && clicked.data && clicked.data.name) {
                            // Find the planet group
                            const planet = planets.find(p => p.userData.name === clicked.data.name);
                            if (planet) {
                                focusPlanet(planet);
                            }
                        }
                    }
                }
            });

            function focusPlanet(planet) {
                const distance = planet.userData.radius * 6;
                controls.target.copy(planet.position);
                const offset = new THREE.Vector3(distance, distance / 2, distance);
                camera.position.copy(planet.position).add(offset);
            }

            // Time control slider
            document.getElementById('time-slider').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                timeScale = Math.pow(10, (value - 10) / 20); // Exponential scale
                document.getElementById('time-value').textContent = timeScale.toFixed(1) + 'x';
            });

            // Pause/Reset buttons
            document.getElementById('pause-btn').addEventListener('click', () => {
                isPaused = !isPaused;
                document.getElementById('pause-btn').textContent = isPaused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                camera.position.set(0, 150, 300);
                controls.target.set(0, 0, 0);
                elapsedTime = 0;
            });

            // Awake mode toggle button
            document.getElementById('awake-btn').addEventListener('click', () => {
                isAwakeMode = !isAwakeMode;
                const btn = document.getElementById('awake-btn');

                if (isAwakeMode) {
                    btn.textContent = 'üü¢ Normal';
                    btn.classList.add('active');
                    // Turn off Solar Balls mode if it's on
                    if (isSolarBallsMode) {
                        isSolarBallsMode = false;
                        const solarBtn = document.getElementById('solarballs-btn');
                        solarBtn.textContent = 'üòä Solar Balls';
                        solarBtn.style.background = 'rgba(255, 200, 0, 0.2)';
                    }
                } else {
                    btn.textContent = 'üî¥ Awake';
                    btn.classList.remove('active');
                }

                // Reload all planet and moon textures
                reloadCelestialTextures();
            });

            // Solar Balls mode toggle button
            document.getElementById('solarballs-btn').addEventListener('click', () => {
                isSolarBallsMode = !isSolarBallsMode;
                const btn = document.getElementById('solarballs-btn');

                if (isSolarBallsMode) {
                    btn.textContent = 'üåç Normal';
                    btn.style.background = 'rgba(255, 200, 0, 0.5)';
                    // Turn off Awake mode if it's on
                    if (isAwakeMode) {
                        isAwakeMode = false;
                        const awakeBtn = document.getElementById('awake-btn');
                        awakeBtn.textContent = 'üî¥ Awake';
                        awakeBtn.classList.remove('active');
                    }
                } else {
                    btn.textContent = 'üòä Solar Balls';
                    btn.style.background = 'rgba(255, 200, 0, 0.2)';
                }

                // Reload all planet and moon textures
                reloadCelestialTextures();
            });

            // Keyboard navigation
            window.addEventListener('keydown', (e) => {
                const planetOrder = ['mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto'];

                // Number keys 1-9 for planets
                if (e.key >= '1' && e.key <= '9') {
                    const index = parseInt(e.key) - 1;
                    const planetName = planetOrder[index];
                    const planet = planets.find(p => p.userData.name === planetName);
                    if (planet) {
                        focusPlanet(planet);
                    }
                }
                // 0 key for Planet QQ
                else if (e.key === '0') {
                    const planetQQ = planets.find(p => p.userData.name === 'planetqq');
                    if (planetQQ) {
                        focusPlanet(planetQQ);
                    }
                }
                // Minus/dash key for Black Hole
                else if (e.key === '-' || e.key === '_') {
                    // Fly to black hole
                    const bhPos = BH_CONFIG.position;
                    const distance = BH_CONFIG.scale * 0.5; // Good viewing distance
                    controls.target.set(bhPos.x, bhPos.y, bhPos.z);
                    camera.position.set(bhPos.x + distance, bhPos.y + distance * 0.3, bhPos.z + distance);
                }
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // Click handler for planet navigation
            renderer.domElement.addEventListener('click', (event) => {
                // Planet click-to-fly
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                const meshes = celestialObjects.map(obj => obj.mesh);
                const intersects = raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const clicked = celestialObjects.find(obj => obj.mesh === intersects[0].object);
                    if (clicked && clicked.data && clicked.data.name) {
                        // Check main planets
                        const planet = planets.find(p => p.userData.name === clicked.data.name);
                        if (planet) {
                            focusPlanet(planet);
                            return;
                        }

                        // Check minor planets
                        const minorPlanet = minorPlanets.find(b => b.userData.name === clicked.data.name);
                        if (minorPlanet) {
                            focusPlanet(minorPlanet);
                            return;
                        }

                        // Check TNOs
                        const tno = transNeptunianObjects.find(b => b.userData.name === clicked.data.name);
                        if (tno) {
                            focusPlanet(tno);
                            return;
                        }

                        // Check outer system bodies
                        const outerBody = outerSystemBodies.find(b => b.userData.name === clicked.data.name);
                        if (outerBody) {
                            focusPlanet(outerBody);
                        }
                    }
                }
            });

            function launchAsteroidAt(planet, impactPoint) {
                // Launch from camera position (POV) - camera stays here!
                const startPos = camera.position.clone();

                // Aim at planet's CURRENT position (fire-and-forget)
                const targetPos = planet.position.clone();

                const asteroidGeometry = new THREE.IcosahedronGeometry(0.8, 1);  // Much smaller
                const asteroidMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffff00,      // Bright yellow
                    roughness: 0.3,
                    emissive: 0xffff00,   // Yellow glow
                    emissiveIntensity: 1.5
                });
                const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
                asteroid.position.copy(startPos);
                scene.add(asteroid);

                // Create tail for asteroid
                const tailGeometry = new THREE.BufferGeometry();
                const tailPositions = new Float32Array(30); // 10 points
                tailGeometry.setAttribute('position', new THREE.BufferAttribute(tailPositions, 3));
                const tailMaterial = new THREE.LineBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.7
                });
                const tail = new THREE.Line(tailGeometry, tailMaterial);

                // Calculate velocity toward planet's current position
                const direction = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
                const speed = 30; // Slower for better collision detection
                activeAsteroids.push({
                    mesh: asteroid,
                    tail: tail,
                    velocity: direction.multiplyScalar(speed),
                    target: targetPos.clone(),  // Store target but don't track it
                    planet: planet
                });
            }

            // Navigation dropdown
            document.getElementById('nav-select').addEventListener('change', (e) => {
                const target = e.target.value.toLowerCase();
                if (!target) return;

                // Handle Sun
                if (target === 'sun' && sun) {
                    const distance = CONFIG.educational.sunRadius * 4;
                    controls.target.set(0, 0, 0);
                    camera.position.set(distance, distance / 2, distance);
                    e.target.value = ''; // Reset dropdown
                    return;
                }

                // Handle planets
                const planet = planets.find(p => p.userData.name.toLowerCase() === target);
                if (planet) {
                    const distance = planet.userData.radius * 6;
                    controls.target.copy(planet.position);
                    const offset = new THREE.Vector3(distance, distance / 2, distance);
                    camera.position.copy(planet.position).add(offset);
                    e.target.value = ''; // Reset dropdown
                    return;
                }

                // Handle moons
                const moon = moons.find(m => m.userData && m.userData.name.toLowerCase() === target);
                if (moon) {
                    const moonWorldPos = new THREE.Vector3();
                    moon.getWorldPosition(moonWorldPos);
                    const moonInfo = MOON_DATA[moon.userData.name];
                    const distance = (moonInfo?.radius || 2) * 8;
                    controls.target.copy(moonWorldPos);
                    const offset = new THREE.Vector3(distance, distance / 2, distance);
                    camera.position.copy(moonWorldPos).add(offset);
                    e.target.value = ''; // Reset dropdown
                    return;
                }

                // Handle minor planets (Ceres)
                const minorPlanet = minorPlanets.find(b => b.userData.name.toLowerCase() === target);
                if (minorPlanet) {
                    const distance = minorPlanet.userData.radius * 6;
                    controls.target.copy(minorPlanet.position);
                    const offset = new THREE.Vector3(distance, distance / 2, distance);
                    camera.position.copy(minorPlanet.position).add(offset);
                    e.target.value = ''; // Reset dropdown
                    return;
                }

                // Handle trans-Neptunian objects
                const tno = transNeptunianObjects.find(b => b.userData.name.toLowerCase() === target);
                if (tno) {
                    const distance = tno.userData.radius * 6;
                    controls.target.copy(tno.position);
                    const offset = new THREE.Vector3(distance, distance / 2, distance);
                    camera.position.copy(tno.position).add(offset);
                    e.target.value = ''; // Reset dropdown
                    return;
                }

                // Handle outer system bodies
                const outerBody = outerSystemBodies.find(b => b.userData.name.toLowerCase() === target);
                if (outerBody) {
                    const distance = outerBody.userData.radius * 6;
                    controls.target.copy(outerBody.position);
                    const offset = new THREE.Vector3(distance, distance / 2, distance);
                    camera.position.copy(outerBody.position).add(offset);
                    e.target.value = ''; // Reset dropdown
                    return;
                }


                // Handle Kuiper Belt
                if (target === 'kuiper') {
                    const kuiperDistance = 1685; // Center of Kuiper Belt (between 1550 and 1820)
                    const viewDistance = 400; // Distance from center to view from
                    controls.target.set(kuiperDistance, 0, 0);
                    camera.position.set(kuiperDistance + viewDistance, viewDistance / 2, viewDistance);
                    e.target.value = ''; // Reset dropdown
                    return;
                }

                // Handle Planet QQ
                if (target === 'planetqq') {
                    const planet = planets.find(p => p.userData.name === 'Planet QQ');
                    if (planet) {
                        const distance = planet.userData.radius * 6;
                        controls.target.copy(planet.position);
                        const offset = new THREE.Vector3(distance, distance / 2, distance);
                        camera.position.copy(planet.position).add(offset);
                        e.target.value = ''; // Reset dropdown
                    }
                    return;
                }

                // Handle Black Hole
                if (target === 'blackhole') {
                    const viewDistance = 300;
                    controls.target.copy(BH_CONFIG.position);
                    camera.position.set(
                        BH_CONFIG.position.x + viewDistance,
                        BH_CONFIG.position.y + viewDistance / 2,
                        BH_CONFIG.position.z + viewDistance
                    );
                    e.target.value = ''; // Reset dropdown
                }
            });

            // Help button - Show instructions overlay
            document.getElementById('help-btn').addEventListener('click', () => {
                const instructions = document.getElementById('instructions');
                instructions.classList.add('visible');
            });

            // Close help button - Hide instructions overlay
            document.getElementById('close-help').addEventListener('click', () => {
                const instructions = document.getElementById('instructions');
                instructions.classList.remove('visible');
            });

            // Click outside to close instructions overlay
            document.getElementById('instructions').addEventListener('click', (e) => {
                if (e.target.id === 'instructions') {
                    e.target.classList.remove('visible');
                }
            });
        }

        function reloadCelestialTextures() {
            // Reload planet textures
            planets.forEach(planetGroup => {
                const planetData = planetGroup.userData;
                const planetMesh = planetGroup.children.find(child => child.type === 'Mesh' && child.geometry.type === 'SphereGeometry');

                if (planetMesh && planetMesh.material) {
                    // Determine the correct texture path
                    let texturePath = `textures/planets/${planetData.name.toLowerCase()}.jpg`;
                    if (planetData.name === 'Earth') texturePath = 'textures/planets/earth_daymap.jpg';
                    if (planetData.name === 'Venus') texturePath = 'textures/planets/venus_surface.jpg';
                    if (planetData.name === 'Planet QQ') texturePath = 'textures/planets/qq.jpg';

                    // Priority: Solar Balls > Awake > Normal
                    if (isSolarBallsMode && SOLARBALLS_TEXTURES[planetData.name]) {
                        texturePath = SOLARBALLS_TEXTURES[planetData.name];
                    } else if (isAwakeMode && AWAKE_TEXTURES[planetData.name]) {
                        texturePath = AWAKE_TEXTURES[planetData.name].awake;
                    } else if (!isAwakeMode && AWAKE_TEXTURES[planetData.name]) {
                        texturePath = AWAKE_TEXTURES[planetData.name].normal;
                    }

                    // Load and apply new texture
                    textureLoader.load(texturePath, (texture) => {
                        planetMesh.material.map = texture;
                        planetMesh.material.needsUpdate = true;
                    });
                }
            });

            // Reload moon textures
            moons.forEach(moonGroup => {
                const moonData = moonGroup.userData;
                const moonMesh = moonGroup.children.find(child => child.type === 'Mesh');

                if (moonMesh && moonMesh.material && moonData.name) {
                    // Determine texture path based on awake mode
                    let texturePath = `textures/moons/${moonData.name.toLowerCase()}.jpg`;
                    if (isAwakeMode && AWAKE_TEXTURES[moonData.name]) {
                        texturePath = AWAKE_TEXTURES[moonData.name].awake;
                    } else if (!isAwakeMode && AWAKE_TEXTURES[moonData.name]) {
                        texturePath = AWAKE_TEXTURES[moonData.name].normal;
                    }

                    // Load and apply new texture
                    textureLoader.load(texturePath, (texture) => {
                        moonMesh.material.map = texture;
                        moonMesh.material.needsUpdate = true;
                    });
                }
            });
        }

        function focusPlanet(planetGroup) {
            const planetPos = new THREE.Vector3();
            planetGroup.getWorldPosition(planetPos);

            const distance = planetGroup.userData.radius * 5;
            const targetPos = planetPos.clone().add(new THREE.Vector3(distance, distance / 2, distance));

            focusTarget = { position: targetPos, lookAt: planetPos };
            focusProgress = 0;

            // Smooth lerp
            const interval = setInterval(() => {
                if (!focusTarget || focusProgress >= 1) {
                    clearInterval(interval);
                    return;
                }
                camera.position.lerp(focusTarget.position, 0.05);
                camera.lookAt(focusTarget.lookAt);
            }, 16);
        }

        // ==================== START ====================
        init();
    </script>
</body>

</html>