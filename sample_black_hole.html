<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>黑洞模拟 – Three.js</title>
    <!-- KaTeX loader with multi-CDN and optional local fallback (no SRI to avoid blocking) -->
    <script>
      (function() {
        function loadCSS(urls) {
          var i = 0;
          function next() {
            if (i >= urls.length) return;
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = urls[i++];
            link.onerror = next;
            document.head.appendChild(link);
          }
          next();
        }
        function loadJS(urls, cb) {
          var i = 0;
          function next() {
            if (i >= urls.length) { cb && cb(false); return; }
            var s = document.createElement('script');
            s.src = urls[i++];
            s.defer = true;
            s.onload = function() { cb && cb(true); };
            s.onerror = next;
            document.head.appendChild(s);
          }
          next();
        }
        var cssUrls = [
          'https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css',
          'https://unpkg.com/katex@0.16.9/dist/katex.min.css',
          'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css',
          // Optional local fallback if you add files to this path
          './vendor/katex/katex.min.css'
        ];
        var jsUrls = [
          'https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js',
          'https://unpkg.com/katex@0.16.9/dist/katex.min.js',
          'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js',
          // Optional local fallback if you add files to this path
          './vendor/katex/katex.min.js'
        ];
        loadCSS(cssUrls);
        loadJS(jsUrls, function(ok) {
          // If KaTeX loads after the initial render, try to re-render
          if (ok && window.katex && typeof window.updateFormula === 'function') {
            try { window.updateFormula(); } catch (e) {}
          }
        });
      })();
    </script>
    <style>
      html, body { height: 100%; }
      body { margin: 0; background: #000; overflow: hidden; }
      canvas { display: block; }
      .credits { position: fixed; left: 12px; bottom: 10px; color: #999; font: 12px/1.4 system-ui, sans-serif; }
      .credits a { color: #bbb; text-decoration: none; }
      .formula { position: fixed; left: 12px; top: 10px; color: #bcd; font: 13px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; white-space: pre; pointer-events: none; z-index: 10; opacity: 0.9; }
      .page-title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #cde; font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; font-weight: 700; text-align: center; pointer-events: none; z-index: 11; opacity: 0.95; }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.159.0/build/three.module.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="formula" class="formula"></div>
    <div id="pageTitle" class="page-title">Paczynski–Wiita 黑洞<br>物理模拟（作者：李怀普）</div>
    

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';
      import { EffectComposer } from 'https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/RenderPass.js';
      import { AfterimagePass } from 'https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/AfterimagePass.js';
      import { UnrealBloomPass } from 'https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/UnrealBloomPass.js';
      import { Line2 } from 'https://unpkg.com/three@0.159.0/examples/jsm/lines/Line2.js';
      import { LineMaterial } from 'https://unpkg.com/three@0.159.0/examples/jsm/lines/LineMaterial.js';
      import { LineGeometry } from 'https://unpkg.com/three@0.159.0/examples/jsm/lines/LineGeometry.js';
      import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

      // Parameters object for GUI-driven updates
      const params = {
        a: 10, b: 16, c: -1,
        x0: 3, y0: 1, z0: 15,
        dt: 0.0045,
        steps: 260000,
        linewidth: 0.0065,
        gradient: 'Match', // 'Match' | 'Rainbow'
        bloomStrength: 1.6,
        bloomRadius: 0.6,
        bloomThreshold: 0.0,
        rotationX: 0.0027,
        rotationY: 0.0031,
        mode: 'Particles', // 'Particles' | 'Line'
        system: 'BlackHole', // 'Zhou' | 'BlackHole'
        // Black hole parameters (normalized units by default)
        G: 1.0,
        M: 1.0,
        cLight: 1.0,
        diskInner: 3.4,  // in units of r_s; just outside ISCO (3 r_s)
        diskOuter: 17.0, // r_s units
        particleCount: 7000,
        particleSize: 0.005,
        particleColor: 0xFFFFFF,
        trailDamp: 0.80,
        speedScale: 20.0,
        // Cinematic FX
        beamingEnabled: true,
        beamingPower: 1.9,
        photonRingEnabled: true,
        photonRingWidth: 0.205,
        photonRingBrightness: 4.0,
        photonRingColor: 0xFFFFFF,
        glowEnabled: true,
        glowStrength: 0.15,
        starfieldEnabled: true,
        // Composition
        diskTiltDeg: 90,
      };

      // RK4 integrator for Zhou attractor
      function rk4step(x, y, z, dt, a, b, c) {
        const f = (x, y, z) => ({
          dx: a * (y - x),
          dy: b * x - x * z,
          dz: c * z + x * y,
        });
        const k1 = f(x, y, z);
        const k2 = f(x + 0.5 * dt * k1.dx, y + 0.5 * dt * k1.dy, z + 0.5 * dt * k1.dz);
        const k3 = f(x + 0.5 * dt * k2.dx, y + 0.5 * dt * k2.dy, z + 0.5 * dt * k2.dz);
        const k4 = f(x + dt * k3.dx, y + dt * k3.dy, z + dt * k3.dz);
        x += (dt / 6) * (k1.dx + 2 * k2.dx + 2 * k3.dx + k4.dx);
        y += (dt / 6) * (k1.dy + 2 * k2.dy + 2 * k3.dy + k4.dy);
        z += (dt / 6) * (k1.dz + 2 * k2.dz + 2 * k3.dz + k4.dz);
        return [x, y, z];
      }

      // Multi-stop gradient that matches the screenshot palette
      // Stops: yellow -> cyan/teal -> blue -> magenta/violet
      const matchStops = [
        { t: 0.00, color: 0xFFD34A }, // warm yellow
        { t: 0.22, color: 0x37D1C9 }, // teal with hint of green
        { t: 0.52, color: 0x3B82F6 }, // blue
        { t: 0.78, color: 0xA855F7 }, // magenta
        { t: 1.00, color: 0x7C3AED }, // violet
      ];

      function lerpColor(c1, c2, t) {
        const r1 = (c1 >> 16) & 255, g1 = (c1 >> 8) & 255, b1 = c1 & 255;
        const r2 = (c2 >> 16) & 255, g2 = (c2 >> 8) & 255, b2 = c2 & 255;
        const r = r1 + (r2 - r1) * t;
        const g = g1 + (g2 - g1) * t;
        const b = b1 + (b2 - b1) * t;
        return [r / 255, g / 255, b / 255];
      }

      function sampleGradientStops(stops, t) {
        // clamp and find surrounding stops
        if (t <= 0) return lerpColor(stops[0].color, stops[0].color, 0);
        if (t >= 1) return lerpColor(stops[stops.length - 1].color, stops[stops.length - 1].color, 0);
        for (let i = 0; i < stops.length - 1; i++) {
          const s0 = stops[i];
          const s1 = stops[i + 1];
          if (t >= s0.t && t <= s1.t) {
            const u = (t - s0.t) / (s1.t - s0.t);
            return lerpColor(s0.color, s1.color, u);
          }
        }
        return lerpColor(stops[0].color, stops[stops.length - 1].color, t); // fallback
      }

      // Buffers and generator
      let lineGeom, lineMat, line, bloom, afterimage, composer, renderer, camera, scene, controls;
      let pointsGeom, pointsMat, points;
      let pState; // Float32Array of size particleCount * 3 (positions)
      let pVel;   // Float32Array of size particleCount * 3 (velocities)
      let bhSphere;
      let photonRing;
      let photonGlow;
      let photonGlowOuter;

      function generateTrajectory() {
        let x = params.x0, y = params.y0, z = params.z0;
        const steps = params.steps;
        const positions = new Float32Array(steps * 3);
        const colors = new Float32Array(steps * 3);
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

        for (let i = 0; i < steps; i++) {
          [x, y, z] = rk4step(x, y, z, params.dt, params.a, params.b, params.c);
          positions[3 * i + 0] = x;
          positions[3 * i + 1] = y;
          positions[3 * i + 2] = z;
          minX = Math.min(minX, x); maxX = Math.max(maxX, x);
          minY = Math.min(minY, y); maxY = Math.max(maxY, y);
          minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);

          // Color selection: 'Match' biases left lobe to warm hues and right to cool/violet
          let r, g, b;
          if (params.gradient === 'Rainbow') {
            const t = i / (steps - 1);
            const h = t;
            const s = 0.9, v = 1.0;
            const f = (n, k = (n + h * 6) % 6) => v - v * s * Math.max(0, Math.min(k, 4 - k, 1));
            r = f(5); g = f(3); b = f(1);
          } else {
            // Map based on sign of x to differentiate lobes, then progress within each lobe
            const lobe = x < 0 ? 0.0 : 0.5; // left half warm, right half cool/violet
            const prog = (i / (steps - 1)) * 0.5; // progression within half
            const [rr, gg, bb] = sampleGradientStops(matchStops, lobe + prog);
            r = rr; g = gg; b = bb;
          }
          colors[3 * i + 0] = r;
          colors[3 * i + 1] = g;
          colors[3 * i + 2] = b;
        }

        // Normalize to fit in view
        const spanX = maxX - minX, spanY = maxY - minY, spanZ = maxZ - minZ;
        const span = Math.max(spanX, spanY, spanZ);
        const inv = 1 / span;
        for (let i = 0; i < steps; i++) {
          positions[3 * i + 0] = (positions[3 * i + 0]) * inv;
          positions[3 * i + 1] = (positions[3 * i + 1]) * inv;
          positions[3 * i + 2] = (positions[3 * i + 2]) * inv;
        }
        return { positions, colors };
      }

      // Three.js scene
      // Initialize Three.js
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 200);
      camera.position.set(0.0, 0.0, 1.1);
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Line setup
      lineGeom = new LineGeometry();
      lineMat = new LineMaterial({
        linewidth: params.linewidth,
        vertexColors: true,
        transparent: true,
        depthTest: true,
        blending: THREE.AdditiveBlending,
        opacity: 0.95,
      });
      lineMat.resolution.set(window.innerWidth, window.innerHeight);
      line = new Line2(lineGeom, lineMat);
      scene.add(line);
      // Black hole event horizon visual (hidden unless system is BlackHole)
      const bhMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      bhSphere = new THREE.Mesh(new THREE.SphereGeometry(0.04, 32, 16), bhMat);
      scene.add(bhSphere);

      // Starfield background that moves with the black hole
      let stars;
      function setupStarfield() {
        if (stars) { scene.remove(stars); stars.geometry.dispose(); stars.material.dispose(); stars = null; }
        const starCount = 3500;
        const radius = 60; // large sphere around origin
        const positions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
          const u = Math.random();
          const v = Math.random();
          const phi = 2 * Math.PI * u;
          const cosTheta = 2 * v - 1;
          const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
          const r = radius * (0.7 + 0.3 * Math.random());
          const x = r * Math.cos(phi) * sinTheta;
          const y = r * Math.sin(phi) * sinTheta;
          const z = r * cosTheta;
          positions[i*3+0] = x; positions[i*3+1] = y; positions[i*3+2] = z;
        }
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({ size: 0.0035, color: 0xA0B8FF, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthTest: true, depthWrite: false });
        stars = new THREE.Points(geom, mat);
        stars.visible = params.starfieldEnabled;
        scene.add(stars);
      }
      setupStarfield();

      // Bloom
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), params.bloomStrength, params.bloomRadius, params.bloomThreshold);
      afterimage = new AfterimagePass(params.trailDamp);
      composer.addPass(afterimage);
      composer.addPass(bloom);

      // First build
      rebuildGeometry();
      setupParticles();
      applyMode();
      updateFormula();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        lineMat.resolution.set(window.innerWidth, window.innerHeight);
      });

      // Animate with adjustable rotation
      function animate() {
        requestAnimationFrame(animate);
        if (line) {
          line.rotation.y += params.rotationY;
          line.rotation.x += params.rotationX;
        }
        if (stars) {
          // move stars subtly with the same controls so it "follows" the BH scene motion
          stars.rotation.y += params.rotationY * 0.5;
          stars.rotation.x += params.rotationX * 0.5;
        }
        if (photonRing) {
          photonRing.quaternion.copy(camera.quaternion);
          photonRing.position.set(0,0,0);
        }
        if (photonGlow) {
          photonGlow.quaternion.copy(camera.quaternion);
          photonGlow.position.set(0,0,0);
        }
        if (photonGlowOuter) {
          photonGlowOuter.quaternion.copy(camera.quaternion);
          photonGlowOuter.position.set(0,0,0);
        }
        
        if (points) updateParticles();
        controls.update();
        composer.render();
      }
      animate();

      // Rebuild helpers
      function rebuildGeometry() {
        if (params.system === 'BlackHole') {
          // Hide line for Black Hole mode; no Zhou trajectory
          if (line) line.visible = false;
          updateFormula();
          return;
        }
        const { positions, colors } = generateTrajectory();
        lineGeom.setPositions(positions);
        lineGeom.setColors(colors);
        updateFormula();
      }

      

      // GUI controls
      const gui = new GUI({ title: '控制面板' });
      // 隐藏“模型”文件夹（仅保留黑洞模拟相关）
      const fModel = gui.addFolder('模型');
      if (typeof fModel.hide === 'function') fModel.hide();

      const fRender = gui.addFolder('渲染');
      fRender.add(params, 'linewidth', 0.001, 0.02, 0.0005).name('线宽').onChange(v => { lineMat.linewidth = v; });
      const fBloom = fRender.addFolder('泛光');
      fBloom.add(params, 'bloomStrength', 0.0, 2.5, 0.05).name('强度').onChange(v => { bloom.strength = v; });
      fBloom.add(params, 'bloomRadius', 0.0, 1.0, 0.01).name('半径').onChange(v => { bloom.radius = v; });
      fBloom.add(params, 'bloomThreshold', 0.0, 0.99, 0.01).name('阈值').onChange(v => { bloom.threshold = v; });
      const fTrail = fRender.addFolder('拖影');
      fTrail.add(params, 'trailDamp', 0.80, 0.98, 0.001).name('阻尼').onChange(v => { afterimage.uniforms['damp'].value = v; });

      const fMotion = gui.addFolder('运动');
      fMotion.add(params, 'rotationX', 0.0, 0.01, 0.0001).name('绕 X 旋转');
      fMotion.add(params, 'rotationY', 0.0, 0.01, 0.0001).name('绕 Y 旋转');

      const fParticles = gui.addFolder('粒子');
      fParticles.add(params, 'particleCount', 1000, 20000, 500).name('数量').onFinishChange(setupParticles);
      fParticles.add(params, 'particleSize', 0.001, 0.06, 0.001).name('大小').onChange(v => { if (pointsMat) pointsMat.size = v; });
      fParticles.add(params, 'speedScale', 0.2, 30.0, 0.05).name('速度尺度');
      fParticles.add({ reset: () => { setupParticles(); } }, 'reset').name('重置粒子');
      // In case a stale build still adds a color controller, hide it defensively.
      try {
        const maybeColor = (fParticles.controllers || []).find(c => c.property === 'particleColor' || c._name === '粒子颜色');
        if (maybeColor) {
          if (typeof maybeColor.hide === 'function') maybeColor.hide();
          else if (maybeColor.domElement) maybeColor.domElement.style.display = 'none';
        }
      } catch (_) {}

      const fBH = gui.addFolder('黑洞参数');
      fBH.add(params, 'G', 0.5, 2.0, 0.1).name('引力常数').onChange(updateFormula);
      fBH.add(params, 'M', 0.1, 5.0, 0.1).name('质量').onChange(() => { setupParticles(); updateFormula(); });
      fBH.add(params, 'cLight', 0.5, 3.0, 0.1).name('光速').onChange(() => { setupParticles(); updateFormula(); });
      fBH.add(params, 'diskInner', 2.5, 6.0, 0.1).name('盘内缘').onFinishChange(() => { setupParticles(); });
      fBH.add(params, 'diskOuter', 6.0, 30.0, 0.5).name('盘外缘').onFinishChange(() => { setupParticles(); });
      fBH.add(params, 'diskTiltDeg', 0, 90, 1).name('盘倾角(度)');
      const fFX = gui.addFolder('影视特效');
      fFX.add(params, 'beamingEnabled').name('相对论性增亮');
      fFX.add(params, 'beamingPower', 0.0, 5.0, 0.1).name('增亮强度');
      fFX.add(params, 'photonRingEnabled').name('光子环').onChange(() => { if (photonRing) photonRing.visible = params.photonRingEnabled && params.system === 'BlackHole'; });
      fFX.add(params, 'photonRingWidth', 0.01, 0.5, 0.005).name('光子环宽度').onFinishChange(setupParticles);
        fFX.add(params, 'photonRingBrightness', 0.5, 6.0, 0.1).name('光子环亮度').onChange(() => {
          // Keep ring opaque; brightness slider no longer affects opacity
          if (photonRing) photonRing.material.opacity = 1.0;
        });
      fFX.add(params, 'glowEnabled').name('光晕 Glow').onChange(() => {
        const vis = params.glowEnabled && params.system === 'BlackHole';
        if (photonGlow) photonGlow.visible = vis;
        if (photonGlowOuter) photonGlowOuter.visible = vis;
      });
      fFX.add(params, 'glowStrength', 0.0, 2.5, 0.05).name('光晕强度').onChange(() => {
        if (photonGlow) photonGlow.material.opacity = Math.min(0.35, params.glowStrength * 0.18);
        if (photonGlowOuter) photonGlowOuter.material.opacity = Math.min(0.35, params.glowStrength * 0.12);
      });
      // 保留星空背景切换
      fFX.add(params, 'starfieldEnabled').name('星空背景').onChange(() => { if (stars) stars.visible = params.starfieldEnabled; });

      // Particles setup and update
      function setupParticles() {
        // remove existing
        if (points) { scene.remove(points); pointsGeom.dispose(); pointsMat.dispose(); points = null; }
        const N = Math.floor(params.particleCount);
        pointsGeom = new THREE.BufferGeometry();
        const positions = new Float32Array(N * 3);
        const colors = new Float32Array(N * 3);
        pState = new Float32Array(N * 3);
        pVel = new Float32Array(N * 3);
        if (params.system === 'Zhou') {
          // initialize near the starting point with slight random jitter
          for (let i = 0; i < N; i++) {
            const j = i * 3;
            const rx = (Math.random() - 0.5) * 0.1;
            const ry = (Math.random() - 0.5) * 0.1;
            const rz = (Math.random() - 0.5) * 0.1;
            pState[j+0] = params.x0 + rx;
            pState[j+1] = params.y0 + ry;
            pState[j+2] = params.z0 + rz;
            pVel[j+0] = pVel[j+1] = pVel[j+2] = 0;
            positions[j+0] = 0; positions[j+1] = 0; positions[j+2] = 0; // set on first update
            const t = Math.random();
            const lobe = pState[j] < 0 ? 0.0 : 0.5;
            const [r,g,b] = sampleGradientStops(matchStops, lobe + t*0.5);
            colors[j+0] = r; colors[j+1] = g; colors[j+2] = b;
          }
        } else {
          // Black hole disk initialization on x-z plane, annulus [r_in, r_out] in r_s units
          const rs = 2 * params.G * params.M / (params.cLight * params.cLight); // Schwarzschild radius
          const rIn = params.diskInner * rs;
          const rOut = params.diskOuter * rs;
          for (let i = 0; i < N; i++) {
            const j = i * 3;
            // random radius and angle
            const u = Math.random();
            const r = Math.sqrt((1-u) * rIn*rIn + u * rOut*rOut); // area-weighted
            const ang = Math.random() * Math.PI * 2;
            const x = r * Math.cos(ang);
            const z = r * Math.sin(ang);
            const y = (Math.random() - 0.5) * 0.02 * r; // thinner disk thickness for cinematic look
            pState[j+0] = x; pState[j+1] = y; pState[j+2] = z;
            // Keplerian tangential velocity in PW potential
            const vphi = Math.sqrt(params.G * params.M * r) / (r - rs);
            const vx = -vphi * Math.sin(ang);
            const vz =  vphi * Math.cos(ang);
            pVel[j+0] = vx; pVel[j+1] = 0; pVel[j+2] = vz;
            positions[j+0] = x; positions[j+1] = y; positions[j+2] = z;
            // color by radius: warm cream inside → brown outside
            const t = (r - rIn) / (rOut - rIn);
            const inner = 0xFFF1D4, outer = 0x8B5A3C; // cream to brown
            const [rR, rG, rB] = lerpColor(inner, outer, t);
            colors[j+0] = rR; colors[j+1] = rG; colors[j+2] = rB;
          }
        }
        pointsGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
        pointsGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        pointsMat = new THREE.PointsMaterial({ size: params.particleSize, vertexColors: true, color: new THREE.Color(params.particleColor), transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending, depthTest: true, depthWrite: true });
        points = new THREE.Points(pointsGeom, pointsMat);
        // Ensure particles draw before photon ring and write depth
        points.renderOrder = 1;
        scene.add(points);

        // Set BH sphere visibility and scale
        const scale = 1 / 40; // rendering scale used in Zhou particles update; use same for BH for consistency
        const rs = 2 * params.G * params.M / (params.cLight * params.cLight);
        bhSphere.scale.setScalar(rs * scale * 25); // tune constant for visibility
        bhSphere.visible = (params.system === 'BlackHole');
        // Build/update photon ring(s) facing the camera
        if (photonRing) { scene.remove(photonRing); photonRing.geometry.dispose(); photonRing.material.dispose(); photonRing = null; }
        if (photonGlow) { scene.remove(photonGlow); photonGlow.geometry.dispose(); photonGlow.material.dispose(); photonGlow = null; }
        if (photonGlowOuter) { scene.remove(photonGlowOuter); photonGlowOuter.geometry.dispose(); photonGlowOuter.material.dispose(); photonGlowOuter = null; }
        if (params.system === 'BlackHole') {
          // Size ring strictly inside the disk inner edge (screen-space)
          const scl = 0.02; // must match updateParticles scale
          const edgeR = params.diskInner * rs * scl; // disk inner edge radius
          const w = params.photonRingWidth; // fractional width parameter
          const innerR = Math.max(0.0, edgeR * (1.0 - w)); // fully inside the inner edge
          const outerR = edgeR * 0.98; // slight margin within the inner edge
          const geom = new THREE.RingGeometry(innerR, outerR, 128);
          const mat = new THREE.MeshBasicMaterial({
            color: params.photonRingColor,
            side: THREE.DoubleSide,
            transparent: false,
            opacity: 1.0,
            blending: THREE.NormalBlending,
            depthTest: true,
            depthWrite: false
          });
          photonRing = new THREE.Mesh(geom, mat);
          // Draw photon ring after glow to ensure it overlays halo; after particles for occlusion
          photonRing.renderOrder = 3;
          photonRing.visible = params.photonRingEnabled;
          scene.add(photonRing);

          // Feathered glow: inner halo to soften edges + outer halo for gentle aura
          // Inner halo spans slightly inside and slightly outside the opaque ring
          const innerHaloInner = innerR * 0.90;
          const innerHaloOuter = outerR * 1.04;
          const innerGeom = new THREE.RingGeometry(innerHaloInner, innerHaloOuter, 128);
          const innerMat = new THREE.MeshBasicMaterial({
            color: params.photonRingColor,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: Math.min(0.35, params.glowStrength * 0.18),
            blending: THREE.AdditiveBlending,
            depthTest: true,
            depthWrite: false
          });
          photonGlow = new THREE.Mesh(innerGeom, innerMat);
          photonGlow.renderOrder = 2; // after particles, before ring
          photonGlow.visible = params.glowEnabled;
          scene.add(photonGlow);

          // Outer halo remains external-only for soft falloff
          const outerHaloInner = outerR * 1.02;
          const outerHaloOuter = outerR * 1.18;
          const outerGeom = new THREE.RingGeometry(outerHaloInner, outerHaloOuter, 128);
          const outerMat = new THREE.MeshBasicMaterial({
            color: params.photonRingColor,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: Math.min(0.35, params.glowStrength * 0.12),
            blending: THREE.AdditiveBlending,
            depthTest: true,
            depthWrite: false
          });
          photonGlowOuter = new THREE.Mesh(outerGeom, outerMat);
          photonGlowOuter.renderOrder = 2; // after particles, before ring
          photonGlowOuter.visible = params.glowEnabled;
          scene.add(photonGlowOuter);
        }
      }

      function updateParticles() {
        if (!points) return;
        const positions = pointsGeom.attributes.position.array;
        const N = positions.length / 3;
        const dt = params.dt * params.speedScale;
        if (params.system === 'Zhou') {
          for (let i = 0; i < N; i++) {
            const j = i * 3;
            const x = pState[j+0], y = pState[j+1], z = pState[j+2];
            const next = rk4step(x, y, z, dt, params.a, params.b, params.c);
            pState[j+0] = next[0]; pState[j+1] = next[1]; pState[j+2] = next[2];
            positions[j+0] = next[0]; positions[j+1] = next[1]; positions[j+2] = next[2];
          }
          const scl = 1 / 40;
          for (let i = 0; i < N; i++) {
            const j = i * 3;
            positions[j+0] *= scl; positions[j+1] *= scl; positions[j+2] *= scl;
          }
        } else {
          // Black hole motion using Velocity Verlet with PW potential
          const rs = 2 * params.G * params.M / (params.cLight * params.cLight);
          const scl = 0.02; // scale to fit view
          const ax = new Float32Array(N); // temporary magnitude holder per particle
          const colors = pointsGeom.attributes.color.array;
          for (let i = 0; i < N; i++) {
            const j = i * 3;
            // current acceleration
            const rx = pState[j+0], ry = pState[j+1], rz = pState[j+2];
            const r = Math.sqrt(rx*rx + ry*ry + rz*rz);
            const aMag = params.G * params.M / ((r - rs) * (r - rs)); // dPhi/dr
            // unit vector
            const ux = rx / r, uy = ry / r, uz = rz / r;
            // velocity half-step
            pVel[j+0] += -aMag * ux * dt * 0.5;
            pVel[j+1] += -aMag * uy * dt * 0.5;
            pVel[j+2] += -aMag * uz * dt * 0.5;
            // position update
            pState[j+0] += pVel[j+0] * dt;
            pState[j+1] += pVel[j+1] * dt;
            pState[j+2] += pVel[j+2] * dt;
            // new acceleration
            const r2x = pState[j+0], r2y = pState[j+1], r2z = pState[j+2];
            const r2 = Math.sqrt(r2x*r2x + r2y*r2y + r2z*r2z);
            const aMag2 = params.G * params.M / ((r2 - rs) * (r2 - rs));
            const ux2 = r2x / r2, uy2 = r2y / r2, uz2 = r2z / r2;
            // velocity second half-step
            pVel[j+0] += -aMag2 * ux2 * dt * 0.5;
            pVel[j+1] += -aMag2 * uy2 * dt * 0.5;
            pVel[j+2] += -aMag2 * uz2 * dt * 0.5;
            // safety: if particle crosses near horizon, respawn in disk
            if (!isFinite(r2) || r2 <= rs * 1.05) {
              const rIn = params.diskInner * rs;
              const rOut = params.diskOuter * rs;
              const u = Math.random();
              const rNew = Math.sqrt((1-u) * rIn*rIn + u * rOut*rOut);
              const ang = Math.random() * Math.PI * 2;
              const x = rNew * Math.cos(ang);
              const z = rNew * Math.sin(ang);
              const y = (Math.random() - 0.5) * 0.02 * rNew;
              pState[j+0] = x; pState[j+1] = y; pState[j+2] = z;
              const vphi = Math.sqrt(params.G * params.M * rNew) / (rNew - rs);
              pVel[j+0] = -vphi * Math.sin(ang);
              pVel[j+1] = 0;
              pVel[j+2] =  vphi * Math.cos(ang);
            }
            // write positions with cinematic tilt (edge-on)
            const xw = pState[j+0] * scl;
            const yw = pState[j+1] * scl;
            const zw = pState[j+2] * scl;
            const th = params.diskTiltDeg * Math.PI / 180;
            const cy = Math.cos(th), sy = Math.sin(th);
            const y2 = cy * yw - sy * zw;
            const z2 = sy * yw + cy * zw;
            positions[j+0] = xw;
            positions[j+1] = y2;
            positions[j+2] = z2;
            // Relativistic beaming approximation on color
            if (params.beamingEnabled) {
              const vx = pVel[j+0], vy = pVel[j+1], vz = pVel[j+2];
              const vmag = Math.sqrt(vx*vx + vy*vy + vz*vz);
              const beta = Math.min(0.99, vmag / params.cLight);
              const vhatx = vx / (vmag || 1e-9), vhaty = vy / (vmag || 1e-9), vhatz = vz / (vmag || 1e-9);
              const pwx = positions[j+0], pwy = positions[j+1], pwz = positions[j+2];
              const vdx = (camera.position.x - pwx), vdy = (camera.position.y - pwy), vdz = (camera.position.z - pwz);
              const vdn = Math.sqrt(vdx*vdx + vdy*vdy + vdz*vdz) || 1e-9;
              const vdhx = vdx / vdn, vdhy = vdy / vdn, vdhz = vdz / vdn;
              const cosT = vhatx*vdhx + vhaty*vdhy + vhatz*vdhz;
              const D = 1.0 / (Math.max(0.05, (1.0 - beta * cosT)));
              const boost = Math.min(6.0, Math.max(0.4, Math.pow(D, params.beamingPower)));
              const rIn = params.diskInner * rs;
              const rOut = params.diskOuter * rs;
              const r = Math.sqrt(pState[j+0]*pState[j+0] + pState[j+1]*pState[j+1] + pState[j+2]*pState[j+2]);
              const t = Math.min(1, Math.max(0, (r - rIn) / (rOut - rIn)));
              const inner = 0xFFF1D4, outer = 0x8B5A3C;
              const [rR, rG, rB] = lerpColor(inner, outer, t);
              colors[j+0] = Math.min(1, rR * boost);
              colors[j+1] = Math.min(1, rG * boost);
              colors[j+2] = Math.min(1, rB * boost);
            }
          }
          if (params.beamingEnabled) pointsGeom.attributes.color.needsUpdate = true;
        }
        pointsGeom.attributes.position.needsUpdate = true;
      }

      function applyMode() {
        // Force particles-only view when in Black Hole mode
        const showParticles = (params.system === 'BlackHole') ? true : (params.mode === 'Particles');
        if (points) points.visible = showParticles;
        if (line) line.visible = !showParticles && (params.system !== 'BlackHole');
        bhSphere.visible = (params.system === 'BlackHole' && showParticles);
        updateFormula();
      }

      // Render helper: try KaTeX; otherwise fallback to plain text
      function renderFormula(latex, fallbackLines) {
        const el = document.getElementById('formula');
        if (!el) return;
        const fallbackText = Array.isArray(fallbackLines) ? fallbackLines.join('\n') : String(fallbackLines || '');
        try {
          if (window.katex && typeof window.katex.render === 'function') {
            el.innerHTML = '';
            el.style.whiteSpace = 'normal';
            window.katex.render(latex, el, { throwOnError: false });
          } else {
            el.textContent = fallbackText;
            el.style.whiteSpace = 'pre';
          }
        } catch (e) {
          el.textContent = fallbackText;
          el.style.whiteSpace = 'pre';
        }
      }

      // Update formula overlay with current parameters
      function updateFormula() {
        let lines;
        let latex = '';
        if (params.system === 'BlackHole') {
          const rs = 2 * params.G * params.M / (params.cLight * params.cLight);
          lines = [
            '黑洞（施瓦西，Paczynski–Wiita 近似）',
            '假设：非旋转（a = 0）；未建模 Kerr 框拖拽',
            'r_s = 2 G M / c^2',
            'Φ(r) = -GM / (r - r_s)',
            'a(r) = - dΦ/dr · r̂ = -GM / (r - r_s)^2 · r̂',
            'v_φ(r) ≈ √(GM r) / (r - r_s)',
            '倾斜：y\' = cosθ · y − sinθ · z， z\' = sinθ · y + cosθ · z',
            '相对论性增亮（近似）：D ≈ 1 / (1 − β cosθ)，β = |v|/c',
            '亮度增强：I ≈ I₀ · D^k（k = 增亮强度）',
            '光子环半径 ≈ 0.90 · 盘内缘 · r_s · 缩放',
            '环半径：r_in = R(1 − w), r_out = R(1 + w)（w = 宽度）',
            '',
            `G=${params.G.toFixed(2)}, M=${params.M.toFixed(2)}, c=${params.cLight.toFixed(2)}`,
            `r_s = ${rs.toFixed(3)}（单位）`,
            `盘：[${params.diskInner} r_s, ${params.diskOuter} r_s]`,
            `粒子=${params.particleCount}, 大小=${params.particleSize}`,
            `模式=${params.mode}`
          ];
          latex = String.raw`\begin{aligned}
          &\text{黑洞（施瓦西，Paczynski–Wiita 近似）}\\
          r_s &= \frac{2GM}{c^2}\\
          \Phi(r) &= -\frac{GM}{r - r_s}\\
          \vec a(r) &= -\frac{d\Phi}{dr} \, \hat r = -\frac{GM}{(r - r_s)^2} \, \hat r\\
          v_\varphi(r) &\approx \frac{\sqrt{GM\, r}}{r - r_s}\\[4pt]
          D &\approx \frac{1}{1 - \beta \cos\theta},\quad \beta = \frac{|v|}{c}\\
          I &\approx I_0\, D^{k}\\[4pt]
          &\text{参数: } G=${params.G.toFixed(2)}\,,\ M=${params.M.toFixed(2)}\,,\ c=${params.cLight.toFixed(2)}\\
          r_s &= ${rs.toFixed(3)}\\
          &\text{盘: } [${params.diskInner}\, r_s,\; ${params.diskOuter}\, r_s]
          \end{aligned}`;
        } else {
          lines = [
            '周氏吸引子',
            'dx/dt = a (y - x)',
            'dy/dt = b x - x z',
            'dz/dt = c z + x y',
            '',
            `a = ${params.a.toFixed(3)}, b = ${params.b.toFixed(3)}, c = ${params.c.toFixed(3)}`,
            `x0 = ${params.x0}, y0 = ${params.y0}, z0 = ${params.z0}`,
            `时间步长 dt = ${params.dt}, 步数 = ${params.steps}`,
            `模式 = ${params.mode}`
          ];
          latex = String.raw`\begin{aligned}
          \dot x &= a\,(y - x)\\
          \dot y &= b\,x - x\,z\\
          \dot z &= c\,z + x\,y\\[4pt]
          \text{参数: } a=${params.a.toFixed(3)}\,,\ b=${params.b.toFixed(3)}\,,\ c=${params.c.toFixed(3)}\\
          \text{初值: } x_0=${params.x0}\,,\ y_0=${params.y0}\,,\ z_0=${params.z0}\\
          \text{步长: } dt=${params.dt}\,,\ \text{步数: } ${params.steps}
          \end{aligned}`;
        }
        renderFormula(latex, lines);
      }
      // Expose updater so the loader can trigger re-render after KaTeX arrives
      window.updateFormula = updateFormula;
  </script>
  </body>
  <style>
    .save-btn { position: fixed; left: 16px; bottom: 16px; z-index: 20; display: inline-flex; align-items: center; gap: 8px; padding: 10px 12px; border-radius: 10px; font: 12px/1.2 system-ui, sans-serif; color: #fff; background: #0ea5e9; box-shadow: 0 8px 20px rgba(2,132,199,0.35); border: 1px solid rgba(255,255,255,0.25); cursor: pointer; }
    .save-btn:hover { background: #0284c7; }
    .toast { position: fixed; left: 16px; bottom: 66px; z-index: 21; padding: 8px 10px; border-radius: 8px; font: 12px/1.2 system-ui, sans-serif; color: #0f172a; background: #fff; border: 1px solid #e2e8f0; box-shadow: 0 8px 20px rgba(15,23,42,0.15); display: none; }
    .toast.show { display: block; }
    .usage-hint { position: fixed; left: 16px; bottom: 100px; z-index: 21; padding: 6px 8px; border-radius: 6px; font: 12px/1.3 system-ui, sans-serif; color: #e2e8f0; background: rgba(30,41,59,0.55); border: 1px solid rgba(226,232,240,0.2); pointer-events: none; }
  </style>
  <div id="usageHint" class="usage-hint">鼠标左键倾斜，右键移动，滚轮缩放</div>
  <button id="saveBtn" class="save-btn" title="另存为 HTML">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><rect x="7" y="3" width="7" height="5"></rect></svg>
    另存为
  </button>
  <div id="saveToast" class="toast"></div>
  <script type="module">
    function showSaveMsg(type, text) {
      const el = document.getElementById('saveToast');
      if (!el) return;
      el.textContent = text;
      el.classList.add('show');
      clearTimeout(window.__saveToastTimer);
      window.__saveToastTimer = setTimeout(() => { el.classList.remove('show'); }, 3500);
    }

    // Retrieve current HTML to save
    function getHTMLToSave() {
      try {
        return document.documentElement.outerHTML;
      } catch (e) {
        return document.documentElement ? document.documentElement.outerHTML : '';
      }
    }

    function fallbackDownload(html, filename) {
      try {
        const name = filename && filename.endsWith('.html') ? filename : `${(filename||'download')}.html`;
        const blob = new Blob([html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 0);
        showSaveMsg('info', `已下载：${name}`);
      } catch (err) {
        showSaveMsg('error', `下载失败：${err?.message || err}`);
      }
    }

    async function saveAsHtml() {
      const html = getHTMLToSave();
      const defaultName = 'blackhole.html';
      try {
        if (window.showSaveFilePicker) {
          const handle = await window.showSaveFilePicker({
            suggestedName: defaultName,
            types: [{ description: 'HTML 文档', accept: { 'text/html': ['.html'] } }]
          });
          const writable = await handle.createWritable();
          await writable.write(new Blob([html], { type: 'text/html' }));
          await writable.close();
          const savedName = (handle && handle.name) ? handle.name : defaultName;
          showSaveMsg('success', `已保存：${savedName}`);
        } else {
          throw new Error('File System Access API 不支持');
        }
      } catch (err) {
        if (err && (err.name === 'AbortError' || /abort/i.test(err.message))) {
          showSaveMsg('info', '已取消保存');
          return;
        }
        // Fallback to traditional download
        fallbackDownload(html, defaultName);
      }
    }

    document.getElementById('saveBtn')?.addEventListener('click', saveAsHtml);
    window.saveAsHtml = saveAsHtml;
    window.getHTMLToSave = getHTMLToSave;
  </script>
</html>